[{"title":"十大排序算法列举","date":"2017-03-25T08:57:27.000Z","path":"2017/03/25/十大排序算法列举/","text":"排序算法说明（1）排序的定义：对一序列对象根据某个关键字进行排序；输入：n个数：a1,a2,a3,…,an输出：n个数的排列:a1’,a2’,a3’,…,an’，使得a1’ 再讲的形象点就是排排坐，调座位，高的站在后面，矮的站在前面咯。 （2）对于评述算法优劣术语的说明稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序：所有排序操作都在内存中完成；外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度: 一个算法执行所耗费的时间。空间复杂度: 运行完一个程序所需内存的大小。 关于时间空间复杂度的更多了解请看程杰大大编写的《大话数据结构》还是很赞的，通俗易懂。O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n) （3）排序算法图片总结(图片来源于网络):排序对比：这里写图片描述 图片名词解释：n: 数据规模k:“桶”的个数In-place: 占用常数内存，不占用额外内存Out-place: 占用额外内存 排序分类：","tags":[{"name":"算法","slug":"算法","permalink":"https://guoliuxu.github.io/tags/算法/"},{"name":"排序","slug":"排序","permalink":"https://guoliuxu.github.io/tags/排序/"}]},{"title":"十大排序算法之基数排序","date":"2017-03-25T08:56:52.000Z","path":"2017/03/25/十大排序算法之基数排序/","text":"(1)算法简介 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。 (2)算法描述和实现具体算法描述如下： .取得数组中的最大数，并取得位数； .arr为原始数组，从最低位开始取每个位组成radix数组； .对radix进行计数排序（利用计数排序适用于小范围数的特点）； Javascript代码实现：12345678910111213141516171819202122232425262728293031323334353637** * 基数排序适用于： * (1)数据范围较小，建议在小于1000 * (2)每个数值都要大于等于0 * @author xiazdong * @param arr 待排序数组 * @param maxDigit 最大位数 *///LSD Radix Sortfunction radixSort(arr, maxDigit) &#123; var mod = 10; var dev = 1; var counter = []; console.time(&apos;基数排序耗时&apos;); for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]== null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; var pos = 0; for(var j = 0; j &lt; counter.length; j++) &#123; var value = null; if(counter[j]!=null) &#123; while ((value = counter[j].shift()) != null) &#123; arr[pos++] = value; &#125; &#125; &#125; &#125; console.timeEnd(&apos;基数排序耗时&apos;); return arr;&#125;var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(radixSort(arr,2)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] php代码实现:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#基数排序,此处仅对正整数进行排序，至于负数和浮点数，需要用到补码，各位有兴趣自行研究 #计数排序 #@param $arr 待排序数组 #@param $digit_num 根据第几位数进行排序 function counting_sort(&amp;$arr, $digit_num = false) &#123; if ($digit_num !== false) &#123; #如果参数$digit_num不为空，则根据元素的第$digit_num位数进行排序 for ($i = 0; $i &lt; count($arr); $i++) &#123; $arr_temp[$i] = get_specific_digit($arr[$i], $digit_num); &#125; &#125; else &#123; $arr_temp = $arr; &#125; $max = max($arr); $time_arr = array(); #储存元素出现次数的数组 #初始化出现次数数组 for ($i = 0; $i &lt;= $max; $i++) &#123; $time_arr[$i] = 0; &#125; #统计每个元素出现次数 for ($i = 0; $i &lt; count($arr_temp); $i++) &#123; $time_arr[$arr_temp[$i]]++; &#125; #统计每个元素比其小或相等的元素出现次数 for ($i = 0; $i &lt; count($time_arr) - 1; $i++) &#123; $time_arr[$i + 1] += $time_arr[$i]; &#125; #利用出现次数对数组进行排序 for($i = count($arr) - 1; $i &gt;= 0; $i--) &#123; $sorted_arr[$time_arr[$arr_temp[$i]] - 1] = $arr[$i]; $time_arr[$arr_temp[$i]]--; &#125; $arr = $sorted_arr; ksort($arr); #忽略这次对key排序的效率损耗 &#125; #计算某个数的位数 function get_digit($number) &#123; $i = 1; while ($number &gt;= pow(10, $i)) &#123; $i++; &#125; return $i; &#125; #获取某个数字的从个位算起的第i位数 function get_specific_digit($num, $i) &#123; if ($num &lt; pow(10, $i - 1)) &#123; return 0; &#125; return floor($num % pow(10, $i) / pow(10, $i - 1)); &#125; #基数排序,以计数排序作为子排序过程 function radix_sort(&amp;$arr) &#123; #先求出数组中最大的位数 $max = max($arr); $max_digit = get_digit($max); for ($i = 1; $i &lt;= $max_digit; $i++) &#123; counting_sort($arr, $i); &#125; &#125; $arr = array(23,0,32,45,56,75,43,0,34); radix_sort($arr); var_dump($arr); (3)算法分析最佳情况：T(n) = O(n k)最差情况：T(n) = O(n k)平均情况：T(n) = O(n * k) 基数排序有两种方法： MSD 从高位开始进行排序LSD 从低位开始进行排序 基数排序 vs 计数排序 vs 桶排序这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶计数排序：每个桶只存储单一键值桶排序：每个桶存储一定范围的数值","tags":[{"name":"算法","slug":"算法","permalink":"https://guoliuxu.github.io/tags/算法/"},{"name":"排序","slug":"排序","permalink":"https://guoliuxu.github.io/tags/排序/"},{"name":"基数","slug":"基数","permalink":"https://guoliuxu.github.io/tags/基数/"}]},{"title":"十大排序算法之桶排序","date":"2017-03-25T08:56:41.000Z","path":"2017/03/25/十大排序算法之桶排序/","text":"(1)算法简介 桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排 (2)算法描述和实现具体算法描述如下： .设置一个定量的数组当作空桶； .遍历输入数据，并且把数据一个一个放到对应的桶里去； .对每个不是空的桶进行排序； .从不是空的桶里把排好序的数据拼接起来。 Javascript代码实现:1234567891011121314151617181920212223242526272829303132333435363738/*方法说明：桶排序@param array 数组@param num 桶的数量*/function bucketSort(array, num) &#123; if (array.length &lt;= 1) &#123; return array; &#125; var len = array.length, buckets = [], result = [], min = max = array[0], regex = &apos;/^[1-9]+[0-9]*$/&apos;, space, n = 0; num = num || ((num &gt; 1 &amp;&amp; regex.test(num)) ? num : 10); console.time(&apos;桶排序耗时&apos;); for (var i = 1; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; &#125; space = (max - min + 1) / num; for (var j = 0; j &lt; len; j++) &#123; var index = Math.floor((array[j] - min) / space); if (buckets[index]) &#123; // 非空桶，插入排序 var k = buckets[index].length - 1; while (k &gt;= 0 &amp;&amp; buckets[index][k] &gt; array[j]) &#123; buckets[index][k + 1] = buckets[index][k]; k--; &#125; buckets[index][k + 1] = array[j]; &#125; else &#123; //空桶，初始化 buckets[index] = []; buckets[index].push(array[j]); &#125; &#125; while (n &lt; num) &#123; result = result.concat(buckets[n]); n++; &#125; console.timeEnd(&apos;桶排序耗时&apos;); return result;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bucketSort(arr,4));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] php代码实现:12345678910111213141516171819//桶排序法$d=array(225,220,41,190,242,185,42,231);$t=array(10000);$n=count($d);for ($i=0;$i&lt;=10000;$i++)&#123; $t[$i]=0;&#125; //t数组初始化为零，用php定义新的数组，默认不予初始化，需要手动初始化for ($i=0;$i&lt;$n;$i++)&#123; $t[$d[$i]]++;&#125; //循环枚举一遍这8个数字，因为他们都是小于等于10000的，所以对于数字$d[i]，我则使$t[$d[i]]++for ($i=0;$i&lt;=10000;$i++)&#123; if ($t[$i]&gt;0)&#123; while ($t[$i]&gt;0)&#123; $t[$i]--; echo($i); echo(&apos;&lt;br /&gt;&apos;); &#125; //打印输出结果 &#125;&#125; (3)算法分析 桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 最佳情况：T(n) = O(n+k)最差情况：T(n) = O(n+k)平均情况：T(n) = O(n2)","tags":[{"name":"算法","slug":"算法","permalink":"https://guoliuxu.github.io/tags/算法/"},{"name":"桶排序","slug":"桶排序","permalink":"https://guoliuxu.github.io/tags/桶排序/"}]},{"title":"十大排序算法之计数排序","date":"2017-03-25T08:56:31.000Z","path":"2017/03/25/十大排序算法之计数排序/","text":"(1)算法简介 计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。 (2)算法描述和实现具体算法描述如下： . 找出待排序的数组中最大和最小的元素； . 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； . 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； . 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 Javascript代码实现：1234567891011121314151617181920212223function countingSort(array) &#123; var len = array.length, B = [], C = [], min = max = array[0]; console.time(&apos;计数排序耗时&apos;); for (var i = 0; i &lt; len; i++) &#123; min = min &lt;= array[i] ? min : array[i]; max = max &gt;= array[i] ? max : array[i]; C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1; &#125; for (var j = min; j &lt; max; j++) &#123; C[j + 1] = (C[j + 1] || 0) + (C[j] || 0); &#125; for (var k = len - 1; k &gt;= 0; k--) &#123; B[C[array[k]] - 1] = array[k]; C[array[k]]--; &#125; console.timeEnd(&apos;计数排序耗时&apos;); return B;&#125;var arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];console.log(countingSort(arr)); //[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9] PHP代码实现：1234567891011121314151617181920212223242526272829303132333435public class CountSort &#123; public static void countSort(int[] arr) &#123; if(arr == null || arr.length == 0) return ; int max = max(arr); int[] count = new int[max+1]; Arrays.fill(count, 0); for(int i=0; i&lt;arr.length; i++) &#123; count[arr[i]] ++; &#125; int k = 0; for(int i=0; i&lt;=max; i++) &#123; for(int j=0; j&lt;count[i]; j++) &#123; arr[k++] = i; &#125; &#125; &#125; public static int max(int[] arr) &#123; int max = Integer.MIN_VALUE; for(int ele : arr) &#123; if(ele &gt; max) max = ele; &#125; return max; &#125;&#125; (3)算法分析 当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。 最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k)","tags":[{"name":"算法","slug":"算法","permalink":"https://guoliuxu.github.io/tags/算法/"},{"name":"排序","slug":"排序","permalink":"https://guoliuxu.github.io/tags/排序/"},{"name":"计数","slug":"计数","permalink":"https://guoliuxu.github.io/tags/计数/"}]},{"title":"十大排序算法之堆排序","date":"2017-03-25T08:56:04.000Z","path":"2017/03/25/十大排序算法之堆排序/","text":"(1)算法简介 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点 (2)算法描述和实现具体算法描述如下： .将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； .将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； .由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 Javascript代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*方法说明：堆排序@param array 待排序数组*/function heapSort(array) &#123; console.time(&apos;堆排序耗时&apos;); if (Object.prototype.toString.call(array).slice(8, -1) === &apos;Array&apos;) &#123; //建堆 var heapSize = array.length, temp; for (var i = Math.floor(heapSize / 2) - 1; i &gt;= 0; i--) &#123; heapify(array, i, heapSize); &#125; //堆排序 for (var j = heapSize - 1; j &gt;= 1; j--) &#123; temp = array[0]; array[0] = array[j]; array[j] = temp; heapify(array, 0, --heapSize); &#125; console.timeEnd(&apos;堆排序耗时&apos;); return array; &#125; else &#123; return &apos;array is not an Array!&apos;; &#125;&#125;/*方法说明：维护堆的性质@param arr 数组@param x 数组下标@param len 堆大小*/function heapify(arr, x, len) &#123; if (Object.prototype.toString.call(arr).slice(8, -1) === &apos;Array&apos; &amp;&amp; typeof x === &apos;number&apos;) &#123; var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp; if (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123; largest = l; &#125; if (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123; largest = r; &#125; if (largest != x) &#123; temp = arr[x]; arr[x] = arr[largest]; arr[largest] = temp; heapify(arr, largest, len); &#125; &#125; else &#123; return &apos;arr is not an Array or x is not a number!&apos;; &#125;&#125;var arr=[91,60,96,13,35,65,46,65,10,30,20,31,77,81,22];console.log(heapSort(arr));//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96] PHP代码实现：12345678910111213141516171819202122232425262728293031323334353637383940414243/堆排序（对简单选择排序的改进）function swap(array &amp;$arr,$a,$b)&#123; $temp = $arr[$a]; $arr[$a] = $arr[$b]; $arr[$b] = $temp;&#125;//调整 $arr[$start]的关键字，使$arr[$start]、$arr[$start+1]、、、$arr[$end]成为一个大根堆（根节点最大的完全二叉树）//注意这里节点 s 的左右孩子是 2*s + 1 和 2*s+2 （数组开始下标为 0 时）function HeapAdjust(array &amp;$arr,$start,$end)&#123; $temp = $arr[$start]; //沿关键字较大的孩子节点向下筛选 //左右孩子计算（我这里数组开始下标识 0） //左孩子2 * $start + 1，右孩子2 * $start + 2 for($j = 2 * $start + 1;$j &lt;= $end;$j = 2 * $j + 1)&#123; if($j != $end &amp;&amp; $arr[$j] &lt; $arr[$j + 1])&#123; $j ++; //转化为右孩子 &#125; if($temp &gt;= $arr[$j])&#123; break; //已经满足大根堆 &#125; //将根节点设置为子节点的较大值 $arr[$start] = $arr[$j]; //继续往下 $start = $j; &#125; $arr[$start] = $temp;&#125;function HeapSort(array &amp;$arr)&#123; $count = count($arr); //先将数组构造成大根堆（由于是完全二叉树，所以这里用floor($count/2)-1，下标小于或等于这数的节点都是有孩子的节点) for($i = floor($count / 2) - 1;$i &gt;= 0;$i --)&#123; HeapAdjust($arr,$i,$count); &#125; for($i = $count - 1;$i &gt;= 0;$i --)&#123; //将堆顶元素与最后一个元素交换，获取到最大元素（交换后的最后一个元素），将最大元素放到数组末尾 swap($arr,0,$i); //经过交换，将最后一个元素（最大元素）脱离大根堆，并将未经排序的新树($arr[0...$i-1])重新调整为大根堆 HeapAdjust($arr,0,$i - 1); &#125;&#125; (3)算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn)","tags":[{"name":"算法","slug":"算法","permalink":"https://guoliuxu.github.io/tags/算法/"},{"name":"排序","slug":"排序","permalink":"https://guoliuxu.github.io/tags/排序/"},{"name":"堆","slug":"堆","permalink":"https://guoliuxu.github.io/tags/堆/"}]},{"title":"十大排序算法之快速排序","date":"2017-03-25T08:55:55.000Z","path":"2017/03/25/十大排序算法之快速排序/","text":"(1)算法简介 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 (2)算法描述和实现快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： .从数列中挑出一个元素，称为 “基准”（pivot）； .重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； .递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序 JavaScript代码实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*方法说明：快速排序@param array 待排序数组*///方法一function quickSort(array, left, right) &#123; console.time(&apos;1.快速排序耗时&apos;); if (Object.prototype.toString.call(array).slice(8, -1) === &apos;Array&apos; &amp;&amp; typeof left === &apos;number&apos; &amp;&amp; typeof right === &apos;number&apos;) &#123; if (left &lt; right) &#123; var x = array[right], i = left - 1, temp; for (var j = left; j &lt;= right; j++) &#123; if (array[j] &lt;= x) &#123; i++; temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; quickSort(array, left, i - 1); quickSort(array, i + 1, right); &#125; console.timeEnd(&apos;1.快速排序耗时&apos;); return array; &#125; else &#123; return &apos;array is not an Array or left or right is not a number!&apos;; &#125;&#125;//方法二var quickSort2 = function(arr) &#123; console.time(&apos;2.快速排序耗时&apos;); if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125;console.timeEnd(&apos;2.快速排序耗时&apos;); return quickSort2(left).concat([pivot], quickSort2(right));&#125;;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(quickSort(arr,0,arr.length-1));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]console.log(quickSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] PHP代码实现：123456789101112131415161718192021222324252627$arr=array(6,3,8,6,4,2,9,5,1); //函数实现快速排序 function quick_sort($arr) &#123; //判断参数是否是一个数组 if(!is_array($arr)) return false; //递归出口:数组长度为1，直接返回数组 $length=count($arr); if($length&lt;=1) return $arr; //数组元素有多个,则定义两个空数组 $left=$right=array(); //使用for循环进行遍历，把第一个元素当做比较的对象 for($i=1;$i&lt;$length;$i++) &#123; //判断当前元素的大小 if($arr[$i]&lt;$arr[0])&#123; $left[]=$arr[$i]; &#125;else&#123; $right[]=$arr[$i]; &#125; &#125; //递归调用 $left=quick_sort($left); $right=quick_sort($right); //将所有的结果合并 return array_merge($left,array($arr[0]),$right); &#125; (3)算法分析 最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(nlogn)","tags":[{"name":"算法","slug":"算法","permalink":"https://guoliuxu.github.io/tags/算法/"},{"name":"排序","slug":"排序","permalink":"https://guoliuxu.github.io/tags/排序/"},{"name":"快速","slug":"快速","permalink":"https://guoliuxu.github.io/tags/快速/"}]},{"title":"十大排序算法之归并排序","date":"2017-03-25T08:55:41.000Z","path":"2017/03/25/十大排序算法之归并排序/","text":"(1)算法简介 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 (2)算法描述和实现具体算法描述如下： .把长度为n的输入序列分成两个长度为n/2的子序列； .对这两个子序列分别采用归并排序； .将两个排序好的子序列合并成一个最终的排序序列。 javascript 代码实现：123456789101112131415161718192021222324252627282930function mergeSort(arr) &#123; //采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right)&#123; var result = []; console.time(&apos;归并排序耗时&apos;); while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); console.timeEnd(&apos;归并排序耗时&apos;); return result;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(mergeSort(arr)); PHP代码实现：12345678910111213141516171819202122232425262728function Merge(array $arr,$start,$mid,$end)&#123; $i = $start; $j=$mid + 1; $k = $start; $temparr = array(); while($i!=$mid+1 &amp;&amp; $j!=$end+1) &#123; if($arr[$i] &gt;= $arr[$j])&#123; $temparr[$k++] = $arr[$j++]; &#125; else&#123; $temparr[$k++] = $arr[$i++]; &#125; &#125; //将第一个子序列的剩余部分添加到已经排好序的 $temparr 数组中 while($i != $mid+1)&#123; $temparr[$k++] = $arr[$i++]; &#125; //将第二个子序列的剩余部分添加到已经排好序的 $temparr 数组中 while($j != $end+1)&#123; $temparr[$k++] = $arr[$j++]; &#125; for($i=$start; $i&lt;=$end; $i++)&#123; $arr[$i] = $temparr[$i]; &#125;&#125; (3)算法分析 最佳情况：T(n) = O(n) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn)","tags":[{"name":"算法","slug":"算法","permalink":"https://guoliuxu.github.io/tags/算法/"},{"name":"排序","slug":"排序","permalink":"https://guoliuxu.github.io/tags/排序/"},{"name":"归并","slug":"归并","permalink":"https://guoliuxu.github.io/tags/归并/"}]},{"title":"十大排序算法之希尔排序","date":"2017-03-25T08:55:31.000Z","path":"2017/03/25/十大排序算法之希尔排序/","text":"(1)算法简介 希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。 (2)算法描述与实现先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： . 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； .按增量序列个数k，对序列进行k 趟排序； .每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。javascript代码实现： 12345678910111213141516171819202122function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; console.time(&apos;希尔排序耗时:&apos;); while(gap &lt; len/5) &#123; //动态定义间隔序列 gap =gap*5+1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap/5)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123; arr[j+gap] = arr[j]; &#125; arr[j+gap] = temp; &#125; &#125; console.timeEnd(&apos;希尔排序耗时:&apos;); return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(shellSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] PHP代码实现：1234567891011121314151617181920function ShellSort(array &amp;$arr)&#123; $count = count($arr); $inc = $count; //增量 do &#123; //计算增量 //$inc = floor($inc / 3) + 1; $inc = ceil($inc / 2); for ($i = $inc; $i &lt; $count; $i++) &#123; $temp = $arr[$i]; //设置哨兵 //需将$temp插入有序增量子表 for ($j = $i - $inc; $j &gt;= 0 &amp;&amp; $arr[$j + $inc] &lt; $arr[$j]; $j -= $inc) &#123; $arr[$j + $inc] = $arr[$j]; //记录后移 &#125; //插入 $arr[$j + $inc] = $temp; &#125; //增量为1时停止循环 &#125; while ($inc &gt; 1);&#125; (3)算法分析 最佳情况：T(n) = O(nlog2n) 最坏情况：T(n) = O(nlog2n) 平均情况：T(n) =O(nlogn)","tags":[{"name":"算法","slug":"算法","permalink":"https://guoliuxu.github.io/tags/算法/"},{"name":"排序","slug":"排序","permalink":"https://guoliuxu.github.io/tags/排序/"},{"name":"希尔","slug":"希尔","permalink":"https://guoliuxu.github.io/tags/希尔/"}]},{"title":"十大排序算法之插入排序","date":"2017-03-25T08:55:22.000Z","path":"2017/03/25/十大排序算法之插入排序/","text":"(1)算法简介 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 (2)算法描述和实现一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： .从第一个元素开始，该元素可以认为已经被排序； .取出下一个元素，在已经排序的元素序列中从后向前扫描； .如果该元素（已排序）大于新元素，将该元素移到下一位置； .重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； .将新元素插入到该位置后； .重复步骤2~5。javascript代码实行123456789101112131415161718function insertionSort(array) &#123; if (Object.prototype.toString.call(array).slice(8, -1) === &apos;Array&apos;) &#123; console.time(&apos;插入排序耗时：&apos;); for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i]; var j = i - 1; while (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123; array[j + 1] = array[j]; j--; &#125; array[j + 1] = key; &#125; console.timeEnd(&apos;插入排序耗时：&apos;); return array; &#125; else &#123; return &apos;array is not an Array!&apos;; &#125;&#125; 改进插入排序： 查找插入位置时使用二分查找的方式 1234567891011121314151617181920212223242526function binaryInsertionSort(array) &#123; if (Object.prototype.toString.call(array).slice(8, -1) === &apos;Array&apos;) &#123; console.time(&apos;二分插入排序耗时：&apos;); for (var i = 1; i &lt; array.length; i++) &#123; var key = array[i], left = 0, right = i - 1; while (left &lt;= right) &#123; var middle = parseInt((left + right) / 2); if (key &lt; array[middle]) &#123; right = middle - 1; &#125; else &#123; left = middle + 1; &#125; &#125; for (var j = i - 1; j &gt;= left; j--) &#123; array[j + 1] = array[j]; &#125; array[left] = key; &#125; console.timeEnd(&apos;二分插入排序耗时：&apos;); return array; &#125; else &#123; return &apos;array is not an Array!&apos;; &#125;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] PHP代码实现：1234567891011121314151617181920212223242526272829303132 function insertSort($arr) &#123; //区分 哪部分是已经排序好的 //哪部分是没有排序的 //找到其中一个需要排序的元素 //这个元素 就是从第二个元素开始，到最后一个元素都是这个需要排序的元素 //利用循环就可以标志出来 //i循环控制 每次需要插入的元素，一旦需要插入的元素控制好了， //间接已经将数组分成了2部分，下标小于当前的（左边的），是排序好的序列 $len=count($arr); for ($i=1; $i &lt; $len; $i++) &#123; //获得当前需要比较的元素值。 $tmp = $arr[$i]; //内层循环控制 比较 并 插入 for ($j = $i - 1; $j &gt;= 0; $j--) &#123; //$arr[$i];//需要插入的元素; $arr[$j];//需要比较的元素 if ($tmp &lt; $arr[$j]) &#123; //发现插入的元素要小，交换位置 //将后边的元素与前面的元素互换 $arr[$j + 1] = $arr[$j]; //将前面的数设置为 当前需要交换的数 $arr[$j] = $tmp; &#125; else &#123; //如果碰到不需要移动的元素 //由于是已经排序好是数组，则前面的就不需要再次比较了。 break; &#125; &#125; &#125; //将这个元素 插入到已经排序好的序列内。 //返回 return $arr;&#125; php插入排序算法改进(二分插入排序算法)：123456789101112131415161718192021222324252627function BinInsertSort($arr) &#123; var $key, $left, $right, $middle; var len=count($arr); for (var i=1; i&lt;$len; $i++) &#123; $key = arr[$i]; $left = 0; $right = $i-1; while ($left&lt;=$right) &#123; $middle = ($left+$right)/2; if (arr[$middle]&gt;$key) $right = $middle-1; else $left = $middle+1; &#125; for(var $j=$i-1; $j&gt;=$left; $j--) &#123; arr[$j+1] = a[$j]; &#125; arr[$left] = $key; &#125; retrun $arr;&#125; (3)算法分析 最佳情况：输入数组按升序排列。T(n) = O(n) 最坏情况：输入数组按降序排列。T(n) = O(n2) 平均情况：T(n) = O(n2)","tags":[{"name":"算法","slug":"算法","permalink":"https://guoliuxu.github.io/tags/算法/"},{"name":"排序","slug":"排序","permalink":"https://guoliuxu.github.io/tags/排序/"},{"name":"插入","slug":"插入","permalink":"https://guoliuxu.github.io/tags/插入/"}]},{"title":"十大排序算法之选择排序","date":"2017-03-25T08:55:12.000Z","path":"2017/03/25/十大排序算法之选择排序/","text":"（1）算法简介 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 (2)算法描述和实现 n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： .初始状态：无序区为R[1..n]，有序区为空 .第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； .n-1趟结束，数组有序化了。 Javascript代码实现:1234567891011121314151617181920function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; console.time(&apos;选择排序耗时&apos;); for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; console.timeEnd(&apos;选择排序耗时&apos;); return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] PHP代码实现:1234567891011121314151617181920function selection_sort($arr) &#123; var $len=count($arr); for($i = 0; $i &lt; $len ; $i++) &#123; $min = $i; //查找最小值 for(var $j = $i + 1; $j &lt; $len; $j++) if(a[$min] &gt; a[$j]) $min = $j; //交换 if($min != $i) &#123; $t = a[$min]; a[$min] = a[$i]; $a[i] = $t; &#125; &#125; return $arr;&#125; (3)算法分析最佳情况：T(n) = O(n2)最差情况：T(n) = O(n2)平均情况：T(n) = O(n2)","tags":[{"name":"算法","slug":"算法","permalink":"https://guoliuxu.github.io/tags/算法/"},{"name":"排序","slug":"排序","permalink":"https://guoliuxu.github.io/tags/排序/"},{"name":"选择","slug":"选择","permalink":"https://guoliuxu.github.io/tags/选择/"}]},{"title":"十大排序算法之冒泡排序","date":"2017-03-25T08:54:59.000Z","path":"2017/03/25/十大排序算法之冒泡排序/","text":"1.冒泡排序（Bubble Sort） 好的，开始总结第一个排序算法，冒泡排序。我想对于它每个学过C语言的都会了解的吧，这可能是很多人接触的第一个排序算法。冒泡排序是与插入排序拥有相等的执行时间，但是两种法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要O(n^2)次交换，而插入排序只要最多O(n)交换。冒泡排序的实现（类似下面）通常会对已经排序好的数列拙劣地执行（O(n^2)），而插入排序在这个例子只需要O(n)个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。冒泡排序如果能在内部循环第一次执行时，使用一个旗标来表示有无需要交换的可能，也有可能把最好的复杂度降低到O(n)。在这个情况，在已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序和比较大小反过来，也可以稍微地改进效率。有时候称为往返排序，因为算法会从数列的一端到另一端之间穿梭往返。 (1)算法描述 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 ###(2)算法描述和实现 具体算法描述如下： .比较相邻的元素。如果第一个比第二个大，就交换它们两个； .对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； .针对所有的元素重复以上的步骤，除了最后一个； .重复步骤1~3，直到排序完成。 JavaScript代码实现：12345678910111213141516function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]` 改进冒泡排序： 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。 改进后算法如下:1234567891011121314151617function bubbleSort2(arr) &#123; console.time(&apos;改进后冒泡排序耗时&apos;); var i = arr.length-1; //初始时,最后位置保持不变 while ( i&gt; 0) &#123; var pos= 0; //每趟开始时,无记录交换 for (var j= 0; j&lt; i; j++) if (arr[j]&gt; arr[j+1]) &#123; pos= j; //记录交换的位置 var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; &#125; i= pos; //为下一趟排序作准备 &#125; console.timeEnd(&apos;改进后冒泡排序耗时&apos;); return arr;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort2(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。 改进后的算法实现为:12345678910111213141516171819202122function bubbleSort3(arr3) &#123; var low = 0; var high= arr.length-1; //设置变量的初始值 var tmp,j; console.time(&apos;2.改进后冒泡排序耗时&apos;); while (low &lt; high) &#123; for (j= low; j&lt; high; ++j) //正向冒泡,找到最大者 if (arr[j]&gt; arr[j+1]) &#123; tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; &#125; --high; //修改high值, 前移一位 for (j=high; j&gt;low; --j) //反向冒泡,找到最小者 if (arr[j]&lt;arr[j-1]) &#123; tmp = arr[j]; arr[j]=arr[j-1];arr[j-1]=tmp; &#125; ++low; //修改low值,后移一位 &#125; console.timeEnd(&apos;2.改进后冒泡排序耗时&apos;); return arr3;&#125;var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(bubbleSort3(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50] PHP代码实现：1234567891011121314151617181920$arr=array(3,44,38,5,47,15,36,26,27,2,46,4,19,50,48); function getpao($arr)&#123; $len=count($arr); //设置一个空数组 用来接收冒出来的泡 //该层循环控制 需要冒泡的轮数 for($i=1;$i&lt;$len;$i++) &#123; //该层循环用来控制每轮 冒出一个数 需要比较的次数 for($k=0;$k&lt;$len-$i;$k++) &#123; if($arr[$k]&gt;$arr[$k+1]) &#123; $tmp=$arr[$k+1]; $arr[$k+1]=$arr[$k]; $arr[$k]=$tmp; &#125; &#125; &#125; return $arr;&#125; 改进算法为双向冒泡排序算法(鸡尾酒排序) 鸡尾酒排序等于是冒泡排序的轻微变形。不同的地方在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的效能，原因是冒泡排序只从一个方向进行比对(由低到高)，每次循环只移动一个项目。 代码片段：12345678910111213141516171819202122232425262728293031$arr=array(3,44,38,5,47,15,36,26,27,2,46,4,19,50,48); function getpao($arr)&#123; $len=count($arr); //设置一个空数组 用来接收冒出来的泡 //该层循环控制 需要冒泡的轮数 for($i=1;$i&lt;$len;) &#123; //该层循环用来控制每轮 冒出一个数 需要比较的次数 for($k=$len-1;$k&gt;$i;--$k) &#123; if($arr[$k]&lt;$arr[$k-1]) &#123; $tmp=$arr[$k]; $arr[$k]=$arr[$k-1]; $arr[$k-1]=$tmp; &#125; &#125; ++$i; for($k=$i;$k&lt;$len;) &#123; if($arr[$k]&gt;$arr[$k+1]) &#123; $tmp=$arr[$k]; $arr[$k]=$arr[$k+1]; $arr[$k+1]=$tmp; &#125; &#125; $len--; &#125; return $arr;&#125;","tags":[{"name":"冒泡","slug":"冒泡","permalink":"https://guoliuxu.github.io/tags/冒泡/"},{"name":"算法","slug":"算法","permalink":"https://guoliuxu.github.io/tags/算法/"},{"name":"排序","slug":"排序","permalink":"https://guoliuxu.github.io/tags/排序/"}]},{"title":"javascript的闭包","date":"2017-03-24T07:20:58.000Z","path":"2017/03/24/javascript的闭包/","text":"一段代码例子 我们先用一旦代码开启本次javascript的闭包的讲解在这段代码是前端开发的经典实例： 12345for(var i=0;i&lt;10;i++)&#123;setTimeout(function()&#123; console.log(i); &#125;,0)&#125; 问题1：这段代码的输出是什么?问题2：如何修改这段代码让他输出0-9? 那么在这里我先来了解一下setTimeout()函数：setTimeout()是window的对象，大家一定要理解在JavaScript中一切都是对象,这会更好的帮助大家理解JavaScript的一些设计模式。大家先看一下这段代码1234alert(1); setTimeout(&quot;alert(2)&quot;, 0); alert(3); //输出顺序是 1,3,2 为什么”2”是最后输出呢呢?正常情况下javascript都是按照顺序执行的。但是我们可能让该语句后面的语句执行完再执行本身，这时就可以用到setTimeout延时0ms来实现了，这就是JavaScript的异步操作。0秒延迟，此回调将会放到一个能立即执行的时段进行触发。javascript代码大体上是自顶向下的，但中间穿插着有关DOM渲染，事件回应等异步代码，他们将组成一个队列，零秒延迟将会实现插队操作。不写第二个参数，浏览器自动配置时间，在IE，FireFox中，第一次配可能给个很大的数字，100ms上下，往后会缩小到最小时间间隔，Safari，chrome，opera则多为10ms上下。现有的 JavaScript 引擎是单线程处理任务的。它把任务放到队列中，不会同步去执行，必须在完成一个任务后才开始另外一个任务。听过上面的解释后因为setTimeout的特殊队列结构后，代码中所有的由setTimeout定义的操作都将放在同一个队列中依次执行，而队列执行的时间，需要等待到函数调用栈清空之后才开始执行。及所有可执行代码执行完毕之后，才开始执行由setTimeout定义的操作。而这些操作进入队列的顺序，则由设定的延迟时间来决定的。即使设置时间为0，它定义的操作仍然需要等待所有代码执行完毕之后才开始执行。这里的延迟时间并非相对于setTimeout执行这一刻，而是相对于其他代码执行完毕这一刻。那么第一个问题的答案就呼之欲出了，答案：输出10个9。那么关于第二题呢就涉及到JavaScript的闭包了。闭包是什么，我们需要看一下。下列的解释是什么？ #javascript 闭包 1.变量的作用域 要理解闭包，首先必须理解Javascript特殊的变量作用域。变量的作用域无非就是两种：全局变量和局部变量。Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。 Js代码12345 var n=999; function f1()&#123; alert(n); &#125; f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。Js代码1234 function f1()&#123; var n=999; &#125; alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！Js代码12345 function f1()&#123; n=999; &#125; f1(); alert(n); // 999 2.如何从外部读取局部变量？ 出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。 Js代码123456 function f1()&#123; n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。这就是Javascript语言特有的“链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ Js代码123456789 function f1()&#123; n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 3.闭包的概念 上一节代码中的f2函数，就是闭包。各种专业文献上的“闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁 4闭包的用途 闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。怎么来理解这句话呢？请看下面的代码。 Js代码123456789101112 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 5.使用闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 6.思考题如果你能理解下面代码的运行结果，应该就算理解闭包的运行机制了。Js代码12345678910 var name = &quot;The Window&quot;; var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); //The Window 什么是闭包: 当内部函数 在定义它的作用域 的外部 被引用时,就创建了该内部函数的闭包 ,如果内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些变量在内存不会被 释放,因为闭包需要它们. 一、什么是闭包？ 闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。相信很少有人能直接看懂这句话，因为他描述的太学术。其实这句话通俗的来说就是：JavaScript中所有的function都是一个闭包。不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。让我们说的更透彻一些。所谓“闭包”，就是在构造函数体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层函数体中的临时变量。这使得只要目标 对象在生存期内始终能保持其方法，就能间接保持原构造函数体当时用到的临时变量值。尽管最开始的构造函数调用已经结束，临时变量的名称也都消失了，但在目 标对象的方法内却始终能引用到该变量的值，而且该值只能通这种方法来访问。即使再次调用相同的构造函数，但只会生成新对象和方法，新的临时变量只是对应新 的值，和上次那次调用的是各自独立的。 二、闭包有什么作用？ 让我们说的更透彻一些。所谓“闭包”，就是在构造函数体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层函数体中的临时变量。这使得只要目标 对象在生存期内始终能保持其方法，就能间接保持原构造函数体当时用到的临时变量值。尽管最开始的构造函数调用已经结束，临时变量的名称也都消失了，但在目 标对象的方法内却始终能引用到该变量的值，而且该值只能通这种方法来访问。即使再次调用相同的构造函数，但只会生成新对象和方法，新的临时变量只是对应新 的值，和上次那次调用的是各自独立的。 三、闭包内的微观世界 如果要更加深入的了解闭包以及函数a和嵌套函数b的关系，我们需要引入另外几个概念：函数的执行环境(excution context)、活动对象(call object)、作用域(scope)、作用域链(scope chain)。以函数a从定义到执行的过程为例阐述这几个概念。 1.当定义函数a的时候，js解释器会将函数a的作用域链(scope chain)设置为定义a时a所在的“环境”，如果a是一个全局函数，则scope chain中只有window对象。2.当执行函数a的时候，a会进入相应的执行环境(excution context)。3.在创建执行环境的过程中，首先会为a添加一个scope属性，即a的作用域，其值就为第1步中的scope chain。即a.scope=a的作用域链。4.然后执行环境会创建一个活动对象(call object)。活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问。创建完活动对象后，把活动对象添加到a的作用域链的最顶端。此时a的作用域链包含了两个对象：a的活动对象和window对象。5.下一步是在活动对象上添加一个arguments属性，它保存着调用函数a时所传递的参数。6.最后把所有函数a的形参和内部的函数b的引用也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定义的环境，即a的作用域。那么理解闭包那么现在就可以这样修改代码，一种是使用自执行函数提供闭条件。二是传入i值并保存在闭包中1自执行函数提供闭条件1234567for(var i=0;i&lt;10;i++)&#123; (function()&#123; setTimeout(function()&#123; console.log(i); &#125;,0) &#125;)(i)&#125; 2.传入i值并保存在闭包中1234567for(var i=0;i&lt;10;i++)&#123; setTimeout((function()&#123; return function()&#123; console.log(i); &#125; &#125;)(i),0);&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"https://guoliuxu.github.io/tags/javascript/"},{"name":"闭包","slug":"闭包","permalink":"https://guoliuxu.github.io/tags/闭包/"}]},{"title":"使用Node.js 搭建一个静态网站","date":"2017-03-23T09:28:06.000Z","path":"2017/03/23/使用Node-js-搭建一个静态网站/","text":"使用Node.js 搭建一个静态网站 首先写一个简单的服务器的雏形12345678910111213const http = require(&apos;http&apos;); // 要使用HTTP服务器或客户端功能，引入http模块const ip = &apos;192.168.1.9&apos;; // 设置ip地址const port = 3000; // 请求端口// 创建服务器，每次请求都出触发一个匿名函数返回：request 请求和 response 响应；request是http.IncomingMessage的一个实例.response是http.ServerResponse的一个实例http.createServer((req,res) =&gt; &#123; res.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text/html&apos;&#125;); // 向请求回复响应头 res.write(&quot;1111111111111&quot;); // 发送一块请求体 res.end() // 结束请求 &#125;).listen(port,ip,() =&gt; &#123; // 开始在指定的主机名和端口接收连接。 console.log(&quot;Server start&quot;); // 控制台输出信息 &#125;); 进行初步 封装成函数，一处修改多处改变，提高代码的重用性 引入URL 模块 获取当前访问URL路径部分 提取到访问url地址，可以进行一些相关操作，返回给用户！ 引入 文件操作模块 fs 读取一个文件内容，例子: 1234fs.readFile(&apos;/etc/passwd&apos;, function (err, data) &#123; if (err) throw err; console.log(data);&#125;); 回调函数传递了两个参数(err, data),data就是文件的内容。如果未指定编码方式，原生buffer就会被返回。 把 文件读取的信息，返回给前台 使用 fs.readFileSync(filename, [options]); 返回文件名为 filename 的文件内容。如果 encoding 选项被指定， 那么这个函数返回一个字符串。如果未指定，则返回一个原生buffer。 这里文件修改后，前台访问的信息还是之前没被修改过的，因为 没有执行 node server.js 去启动，之前的也没有暂停！更新后重启！ 根据上述的小例子，我们是不是可以根据前台访问的url，返回给客户端什么页面呢！对吧！ 开始改造！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 const http = require(&apos;http&apos;); // 要使用HTTP服务器或客户端功能，引入http模块 const url = require(&apos;url&apos;); // 引入URL模块，该模块包含用以 URL 解析的实用函数 const fs = require(&apos;fs&apos;); // 引入文件操作模块 fs const ip = &apos;192.168.1.9&apos;; // 设置ip地址 const port = 3000; // 请求端口，端口大于1000 var server = new http.Server(); // 创建一个server 服务器 server.listen(port,ip); server.on(&apos;request&apos;,function(req,res)&#123; // 解析请求过来的URL var pathname = url.parse(req.url).pathname; // 获取URL的路径部分 // 监听请求的网站，以当前脚本目录为根目录的url地址 console.log(req.url); // 更据请求地址url，让服务器在发送响应前先等待 switch (pathname) &#123; // 判断请求路径信息 case &apos;&apos; || &apos;/&apos;: // 处理网站根目录，指定加载对应的文件 fs.readFile(&quot;./index.html&quot;,function(err,content) &#123; if(err)&#123; res.writeHead(404,&#123;&apos;Content-Type&apos;:&apos;text/html;charset=&quot;UTF-8&quot;&apos;&#125;); res.write(err.message); res.end(); &#125;else&#123; res.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text/html;charset=&quot;UTF-8&quot;&apos;&#125;); res.write(content); res.end(); &#125; &#125;); break;case &apos;/showlist&apos;: fs.readFile(&quot;./showlist.html&quot;,function(err,content) &#123; if(err)&#123; res.writeHead(404,&#123;&apos;Content-Type&apos;:&apos;text/html;charset=&quot;UTF-8&quot;&apos;&#125;); res.write(err.message); res.end(); &#125;else&#123; res.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text/html;charset=&quot;UTF-8&quot;&apos;&#125;); res.write(content); res.end(); &#125; &#125;); break;case &apos;/details&apos;: fs.readFile(&quot;./details.html&quot;,function(err,content) &#123; if(err)&#123; res.writeHead(404,&#123;&apos;Content-Type&apos;:&apos;text/html;charset=&quot;UTF-8&quot;&apos;&#125;); res.write(err.message); res.end(); &#125;else&#123; res.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text/html;charset=&quot;UTF-8&quot;&apos;&#125;); res.write(content); res.end(); &#125; &#125;); break;default:; &#125;&#125;); 这样的一个静态资源网站就完成了！赶快来把页面弄上吧！ 学习总结 从头到尾的搭建过程，了解到了node.js的魅力，大量的api，为我们提供了更多的便利，不过学起来也让我要去了解更多的api！模块聚集地 ：www.npmjs.org","tags":[{"name":"node.js","slug":"node-js","permalink":"https://guoliuxu.github.io/tags/node-js/"}]},{"title":"Laravel5.2目录结构及composer.json文件解析","date":"2017-03-23T09:11:05.000Z","path":"2017/03/23/Laravel5-2目录结构及composer-json文件解析/","text":"Laravel5.2目录结构及composer.json文件解析 目录或文件 说明 ｜– app 包含Controller、Model、路由等在内的应用目录，大部分业务将在该目录下进行｜ ｜– Console 命令行程序目录｜ ｜ ｜– Commands 包含了用于命令行执行的类，可在该目录下自定义类｜ ｜ ｜– Kernel.php 命令调用内核文件，包含commands变量(命令清单，自定义的命令需加入到这里)和schedule方法(用于任务调度，即定时任务)｜ ｜– Events 事件目录｜ ｜– Exceptions 包含了自定义错误和异常处理类｜ ｜– Http HTTP传输层相关的类目录｜ ｜ ｜– Controllers 控制器目录｜ ｜ ｜– Middleware 中间件目录｜ ｜ ｜– Requests 请求类目录｜ ｜ ｜– Kernel.php 包含http中间件和路由中间件的内核文件｜ ｜ ｜– routes.php 强大的路由｜ ｜– Jobs 该目录下包含队列的任务类｜ ｜– Listeners 监听器目录｜ ｜– Providers 服务提供者目录｜ ｜– User.php 自带的模型实例，我们新建的Model默认也存储在该目录｜– bootstrap 框架启动载入目录｜ ｜– app.php 创建框架应用实例｜ ｜– autoload.php 自动加载｜ ｜– cache 存放框架启动缓存，web服务器需要有该目录的写入权限｜– config 各种配置文件的目录｜ ｜– app.php 系统级配置文件｜ ｜– auth.php 用户身份认证配置文件，指定好table和model就可以很方便地用身份认证功能了｜ ｜– broadcasting.php 事件广播配置文件｜ ｜– cache.php 缓存配置文件｜ ｜– compile.php 编译额外文件和类需要的配置文件，一般用户很少用到｜ ｜– database.php 数据库配置文件｜ ｜– filesystems.php 文件系统配置文件，这里可以配置云存储参数｜ ｜– mail.php 电子邮件配置文件｜ ｜– queue.php 消息队列配置文件｜ ｜– services.php 可存放第三方服务的配置信息｜ ｜– session.php 配置session的存储方式、生命周期等信息｜ ｜– view.php 模板文件配置文件，包含模板目录和编译目录等｜– database 数据库相关目录｜ ｜– factories 5.1以上版本的新特性，工厂类目录，也是用于数据填充｜ ｜ ｜– ModelFactory.php 在该文件可定义不同Model所需填充的数据类型｜ ｜– migrations 存储数据库迁移文件｜ ｜– seeds 存放数据填充类的目录｜ ｜– DatabaseSeeder.php 执行php artisan db:seed命令将会调用该类的run方法。该方法可调用执行该目录下其他Seeder类，也可调用factories方法生成ModelFactory里定义的数据模型｜– public 网站入口，应当将ip或域名指向该目录而不是根目录。可供外部访问的css、js和图片等资源皆放置于此｜ ｜– index.php 入口文件｜ ｜– .htaccess Apache服务器用该文件重写URL｜ ｜– web.config IIS服务器用该文件重写URL｜– resources 资源文件目录｜ ｜– assets 可存放包含LESS、SASS、CoffeeScript在内的原始资源文件｜ ｜– lang 本地化文件目录｜ ｜– views 视图文件就放在这啦｜– storage 存储目录。web服务器需要有该目录及所有子目录的写入权限｜ ｜– app 可用于存储应用程序所需的一些文件｜ ｜– framework 该目录下包括缓存、sessions和编译后的视图文件｜ ｜– logs 日志目录｜– tests 测试目录｜– vendor 该目录下包含Laravel源代码和第三方依赖包｜– .env 环境配置文件。config目录下的配置文件会使用该文件里面的参数，不同生产环境使用不同的.env文件即可。｜– artisan 强大的命令行接口，你可以在app/Console/Commands下编写自定义命令｜– composer.json 存放依赖关系的文件｜– composer.lock 锁文件，存放安装时依赖包的真实版本｜– gulpfile.js gulp（一种前端构建工具）配置文件｜– package.json gulp配置文件｜– phpspec.yml phpspec（一种PHP测试框架）配置文件｜– phpunit.xml phpunit（一种PHP测试框架）配置文件｜– server.php PHP内置的Web服务器将把这个文件作为入口。以public/index.php为入口的可以忽略掉该文件 composer.json文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123; &quot;name&quot;: &quot;laravel/laravel&quot;, //项目名称 &quot;description&quot;: &quot;The Laravel Framework.&quot;, //描述 &quot;keywords&quot;: [&quot;framework&quot;, &quot;laravel&quot;], //关键词 &quot;license&quot;: &quot;MIT&quot;, //许可协议 &quot;type&quot;: &quot;project&quot;, //类型 &quot;require&quot;: &#123; &quot;php&quot;: &quot;&gt;=5.5.9&quot;, //PHP版本 &quot;laravel/framework&quot;: &quot;5.2.*&quot; //框架版本 &#125;, &quot;require-dev&quot;: &#123; //依赖包 &quot;fzaninotto/faker&quot;: &quot;~1.4&quot;, &quot;mockery/mockery&quot;: &quot;0.9.*&quot;, &quot;phpunit/phpunit&quot;: &quot;~4.0&quot;, &quot;symfony/css-selector&quot;: &quot;2.8.*|3.0.*&quot;, &quot;symfony/dom-crawler&quot;: &quot;2.8.*|3.0.*&quot; &#125;, &quot;autoload&quot;: &#123; //自动加载 &quot;classmap&quot;: [ &quot;database&quot; ], &quot;psr-4&quot;: &#123; //一种自动加载的规范 &quot;App\\\\&quot;: &quot;app/&quot; &#125; &#125;, &quot;autoload-dev&quot;: &#123; //加载测试 &quot;classmap&quot;: [ &quot;tests/TestCase.php&quot; ] &#125;, &quot;scripts&quot;: &#123; //执行脚本 &quot;post-root-package-install&quot;: [ &quot;php -r \\&quot;copy(&apos;.env.example&apos;, &apos;.env&apos;);\\&quot;&quot; ], &quot;post-create-project-cmd&quot;: [ &quot;php artisan key:generate&quot; ], &quot;post-install-cmd&quot;: [ &quot;php artisan clear-compiled&quot;, &quot;php artisan optimize&quot; ], &quot;post-update-cmd&quot;: [ &quot;php artisan clear-compiled&quot;, &quot;php artisan optimize&quot; ] &#125;, &quot;config&quot;: &#123; //配置项 &quot;preferred-install&quot;: &quot;dist&quot; //优先安装压缩版 &#125;, &quot;repositories&quot;: &#123; //配置composer镜像 &quot;packagist&quot;: &#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;https://packagist.phpcomposer.com&quot; &#125; &#125; &#125;","tags":[{"name":"laravel5.2","slug":"laravel5-2","permalink":"https://guoliuxu.github.io/tags/laravel5-2/"}]},{"title":"vagrant常用命令","date":"2017-03-23T09:07:25.000Z","path":"2017/03/23/vagrant常用命令/","text":"实用小技巧 Vagrant 虚拟机没有正常关闭，会出现一些奇怪的问题 123$ vagrant destroy$ vagrant provision （修改过yaml 文件后，vagrant 也会重新进行编译，配置也会消失） 注意: 销毁当前虚拟机，重构；不用再添加box了，但是虚拟机的配置不见了，例如：composer的国内镜像，Homestead.yaml重新编译生成,测试数据没了 解决办法: 这个文件是每次vagrant 执行重构（上面代码）都会自动执行的脚本文件。 after.sh 有权限问题需要加上 sudo after.sh 添加 查看 composer 和 npm 的配置 12$ composer config --list$ npm config list 如果是 ‘使用 vagrant destroy’ 命令，就可以在后面加上一条命令 编译完成后进入项目目录并重建数据库 项目定时备份项目和数据库 Laravel 插件 laravel-backup 1$ composer require spatie/laravel-backup back-up 插件 启动这个服务后，会在config文件夹目下生成一个 ‘ laravel-backup.php ‘ 的配置文件 配置文件 相关的命令，可以运行 ‘ php artisan ‘ 查看到 12$ php artisan backup:run // 执行备份$ php arisan backup:run --only-db 或 --only-files // 只备份数据库 或 项目 详细请看 官方文档 ; 备份目录，查看 备份的config文件 配置文件 存放路径设置 现在是手动的备份，接下来我们来设置一个自动命令计划任务备份。 设置命令计划任务文件位置 命令计划任务命令 执行命令计划任务命令 怎么让linux自动去监视定时去跑这个任务呢，使用到 linux 中的 cron 工具！homestead 为了这个也带了 一开机就去去执行cron服务。 homestead.yaml文件 注意: schedule:true ‘：’两边不加空格，’ vagrant provision ‘ 会执行失败！需要加上空格 正确写法 在来查下我们linux中cron服务中做了哪些修改。 cron.d; taskmanagerapp内容 NPM DebugError 01 Error 02 Error 03 Error **","tags":[{"name":"vagrant","slug":"vagrant","permalink":"https://guoliuxu.github.io/tags/vagrant/"}]},{"title":"laravel开发计划任务","date":"2017-03-23T08:58:39.000Z","path":"2017/03/23/laravel开发计划任务/","text":"官方手册 ## 基本配置 在使用laravel的计划任务之前，我们只需要向服务器配置一个定时任务就可以了： 1$ crontab -e 写入： 1* * * * * php /path/to/artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1 启动定时任务： 1/etc/init.d/cron start 几种任务方式开始写计划任务，位置在app/console/Kernel.php： 12345678910111213141516protected function schedule(Schedule $schedule)&#123; //这里写我们的定时任务，可以写多个 //执行artisan命令 $schedule-&gt;command(&apos;emails:send&apos;) -&gt;hourly(); //执行回调函数 $schedule-&gt;call(function () &#123; // 在每个礼拜一的 13:00 运行一次... &#125;)-&gt;weekly()-&gt;mondays()-&gt;at(&apos;13:00&apos;); //执行linux命令 $schedule-&gt;exec(&apos;node /home/forge/script.js&apos;)-&gt;daily(); &#125; 避免重复命令运行的进程存在就不运行，不存在则会运行，每分钟检查一次，对无法确定运行时间的程序特别有帮助，尤其是对容易崩溃的消息队列 1$schedule-&gt;command(&apos;emails:send&apos;)-&gt;withoutOverlapping(); 在任务之前和完成之后执行的函数12345678$schedule-&gt;command(&apos;emails:send&apos;) -&gt;daily() -&gt;before(function () &#123; // 任务将要开始... &#125;) -&gt;after(function () &#123; // 任务已完成... &#125;); ping网址1234$schedule-&gt;command(&apos;emails:send&apos;) -&gt;daily() -&gt;pingBefore($url) -&gt;thenPing($url); 依赖于： 1&quot;guzzlehttp/guzzle&quot;: &quot;~5.3|~6.0&quot;","tags":[{"name":"laravel","slug":"laravel","permalink":"https://guoliuxu.github.io/tags/laravel/"},{"name":"计划任务","slug":"计划任务","permalink":"https://guoliuxu.github.io/tags/计划任务/"}]},{"title":"javascript的事件绑定","date":"2017-03-23T08:50:44.000Z","path":"2017/03/23/javascript的事件绑定/","text":"javascript 事件的冒泡 (IE浏览器支持)一.在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window） 如：123&lt;div onclick=&quot;one();&quot; id=&quot;one&quot;&gt; &lt;div onclick=&quot;two()&quot; id=&quot;two&quot;&gt;&lt;/div&gt; &lt;/div&gt; 当点击子集元素two时触发onclick事件运行函数，但是运行完two()后并没有停止，他会触发父级元素onclick事件，运行函数one()，与自己本意不同，事件函数运行方式依次从最小子集元素向外触发同一onclick事件，就像水中的气泡，一点一点往上冒泡，所以叫事件冒泡。 二、需要注意什么1.事件捕获其实有三种方式，事件冒泡只是其中的一种：（1）IE从里到外（inside→outside）的冒泡型事件。（2）Netscape4.0从外到里（outside→inside）的捕获型事件。（3）DOM事件流，先从外到里，再从里到外回到原点（outside→inside→outside）的事件捕获方法（似乎对象将触发两次事件处理，这有什么作用？鄙人不懂！）。 2.不是所有的事件都能冒泡。以下事件不冒泡：blur、focus、load、unload。 3.事件捕获方式在不同浏览器，甚至同种浏览器的不同版本中是有所区别的。如Netscape4.0采用捕获型事件解决方案，其它多数浏览器则支持冒泡型事件解决方案，另外DOM事件流还支持文本节点事件冒泡。 4.事件捕获到达顶层的目标在不同浏览器或不同浏览器版本也是有区别的。在IE6中HTML是接收事件冒泡的，另外大部分浏览器将冒泡延续到window对象，即……body→documen→window。 5.阻止冒泡并不能阻止对象默认行为。比如submit按钮被点击后会提交表单数据，这种行为无须我们写程序定制。 三.阻止冒泡行为1234567function stopBubble(e)&#123; if (e &amp;&amp; e.stopPropagation) e.stopPropagation() //非IE阻止事件冒泡 else window.event.cancelBubble=true //IE阻止事件冒泡&#125; JavaScript 事件的捕获 (非IE浏览器支持)一.事件捕获与事件冒泡触发事件的顺序相反，它在同一事件下，从父级向子集元素，一级一级向下，触发事件。 阻止事件的捕获 1234567function stopBubble(e)&#123; if (e &amp;&amp; e.stopPropagation) e.stopPropagation() //非IE阻止事件冒泡 else window.event.cancelBubble=true //IE阻止事件冒泡&#125; DOM事件流一.DOM(文档对象模型)结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素结点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流DOM同时支持两种事件模型： 捕获型事件和 冒泡型事件，但是，捕获型事件先发生。两种事件流会触发DOM中的所有对象，从 document对象开始，也在document对象结束。DOM事件模型的最独特的性质是，文本节点也触发事件（在IE中不会)DOM2级事件规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件，最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。 在DOM事件流中，实际的目标在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从document到再到后就停止了。下一阶段是处于目标阶段，于是事件在上发生，并在事件处理中被看成是冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。 多数支持DOM事件流的浏览器都实现了一种特定的行为；即使”DOM2级事件”规范明确要求捕获阶段不会涉及事件目标。但IE9+、Safari、Chrome、Firefox、Opera都会在捕获阶段触发事件对象上的事件。结果，就是有两个机会在目标对象上面操作事件。(IE8-浏览器不支持事件流) javascript 事件的监听1、当同一个对象使用.onclick的写法触发多个方法的时候，后一个方法会把前一个方法覆盖掉，也就是说，在对象的onclick事件发生时，只会执行最后绑定的方法。而用事件监听则不会有覆盖的现象，每个绑定的事件都会被执行。如下：123456789101112window.onload = function()&#123; var btn = document.getElementById(&quot;yuanEvent&quot;); btn.onclick = function()&#123; alert(&quot;第一个事件&quot;); &#125; btn.onclick = function()&#123; alert(&quot;第二个事件&quot;); &#125; btn.onclick = function()&#123; alert(&quot;第三个事件&quot;); &#125; &#125; 2、采用事件监听给对象绑定方法后，可以解除相应的绑定，写法如下：123456789101112var eventOne = function()&#123; alert(&quot;第一个监听事件&quot;); &#125; function eventTwo()&#123; alert(&quot;第二个监听事件&quot;); &#125; window.onload = function()&#123; var btn = document.getElementById(&quot;yuanEvent&quot;); btn.addEventListener(&quot;click&quot;,eventOne); btn.addEventListener(&quot;click&quot;,eventTwo); btn.removeEventListener(&quot;click&quot;,eventOne); //解除默认行为&#125; 对函数进行封装后的监听事件如下，兼容各大主流浏览器。：1234567891011121314151617181920function addEventHandler(target,type,func)&#123; if(target.addEventListener)&#123; //监听IE9，谷歌和火狐 target.addEventListener(type, func, false); &#125;else if(target.attachEvent)&#123; target.attachEvent(&quot;on&quot; + type, func); &#125;else&#123; target[&quot;on&quot; + type] = func; &#125; &#125; function removeEventHandler(target, type, func) &#123; if (target.removeEventListener)&#123; //监听IE9，谷歌和火狐 target.removeEventListener(type, func, false); &#125; else if (target.detachEvent)&#123; target.detachEvent(&quot;on&quot; + type, func); &#125;else &#123; delete target[&quot;on&quot; + type]; &#125; &#125; javascript 事件的委托 1，什么是事件委托：通俗的讲，事件就是onclick，onmouseover，onmouseout，等就是事件，委托呢，就是让别人来做，这个事件本来是加在某些元素上的，然而你却加到别人身上来做，完成这个事件。 也就是：利用冒泡的原理，把事件加到父级上，触发执行效果。 好处呢：1，提高性能。 我们可以看一个例子：需要触发每个li来改变他们的背景颜色。12345678910111213141516171819&lt;ul id=&quot;ul&quot;&gt; &lt;li&gt;aaaaaaaa&lt;/li&gt; &lt;li&gt;bbbbbbbb&lt;/li&gt; &lt;li&gt;cccccccc&lt;/li&gt;&lt;/ul&gt;window.onload = function()&#123; var oUl = document.getElementById(&quot;ul&quot;); var aLi = oUl.getElementsByTagName(&quot;li&quot;); for(var i=0; i&lt;aLi.length; i++)&#123; aLi[i].onmouseover = function()&#123; this.style.background = &quot;red&quot;; &#125; aLi[i].onmouseout = function()&#123; this.style.background = &quot;&quot;; &#125; &#125;&#125; 这样我们就可以做到li上面添加鼠标事件。 但是如果说我们可能有很多个li用for循环的话就比较影响性能。 下面我们可以用事件委托的方式来实现这样的效果。html不变123456789101112131415161718192021222324252627window.onload = function()&#123; var oUl = document.getElementById(&quot;ul&quot;); var aLi = oUl.getElementsByTagName(&quot;li&quot;);/*这里要用到事件源：event 对象，事件源，不管在哪个事件中，只要你操作的那个元素就是事件源。ie：window.event.srcElement标准下:event.targetnodeName:找到元素的标签名*/ oUl.onmouseover = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; //alert(target.innerHTML); if(target.nodeName.toLowerCase() == &quot;li&quot;)&#123; target.style.background = &quot;red&quot;; &#125; &#125; oUl.onmouseout = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; //alert(target.innerHTML); if(target.nodeName.toLowerCase() == &quot;li&quot;)&#123; target.style.background = &quot;&quot;; &#125; &#125;&#125; 好处2，新添加的元素还会有之前的事件。 我们还拿这个例子看，但是我们要做动态的添加li。点击button动态添加li 如：123456&lt;input type=&quot;button&quot; id=&quot;btn&quot; /&gt;&lt;ul id=&quot;ul&quot;&gt; &lt;li&gt;aaaaaaaa&lt;/li&gt; &lt;li&gt;bbbbbbbb&lt;/li&gt; &lt;li&gt;cccccccc&lt;/li&gt;&lt;/ul&gt; 不用事件委托我们会这样做：123456789101112131415161718192021window.onload = function()&#123; var oUl = document.getElementById(&quot;ul&quot;); var aLi = oUl.getElementsByTagName(&quot;li&quot;); var oBtn = document.getElementById(&quot;btn&quot;); var iNow = 4; for(var i=0; i&lt;aLi.length; i++)&#123; aLi[i].onmouseover = function()&#123; this.style.background = &quot;red&quot;; &#125; aLi[i].onmouseout = function()&#123; this.style.background = &quot;&quot;; &#125; &#125; oBtn.onclick = function()&#123; iNow ++; var oLi = document.createElement(&quot;li&quot;); oLi.innerHTML = 1111 *iNow; oUl.appendChild(oLi); &#125;&#125; 这样做我们可以看到点击按钮新加的li上面没有鼠标移入事件来改变他们的背景颜色。 因为点击添加的时候for循环已经执行完毕。 那么我们用事件委托的方式来做。就是html不变1234567891011121314151617181920212223242526272829window.onload = function()&#123; var oUl = document.getElementById(&quot;ul&quot;); var aLi = oUl.getElementsByTagName(&quot;li&quot;); var oBtn = document.getElementById(&quot;btn&quot;); var iNow = 4; oUl.onmouseover = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; //alert(target.innerHTML); if(target.nodeName.toLowerCase() == &quot;li&quot;)&#123; target.style.background = &quot;red&quot;; &#125; &#125; oUl.onmouseout = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; //alert(target.innerHTML); if(target.nodeName.toLowerCase() == &quot;li&quot;)&#123; target.style.background = &quot;&quot;; &#125; &#125; oBtn.onclick = function()&#123; iNow ++; var oLi = document.createElement(&quot;li&quot;); oLi.innerHTML = 1111 *iNow; oUl.appendChild(oLi); &#125;&#125; javascript 事件的绑定传统方式123element.onclick = function(e)&#123; // ... &#125;; 1.传统绑定的优点：非常简单和稳定，可以确保它在你使用的不同浏览器中运作一致 处理事件时，this关键字引用的是当前元素，这很有帮组 2.传统绑定的缺点：传统方法只会在事件冒泡中运行，而非捕获和冒泡 一个元素一次只能绑定一个事件处理函数。新绑定的事件处理函数会覆盖旧的事件处理函数 事件对象参数(e)仅非IE浏览器可用 W3C方式123element.addEventListener(&apos;click&apos;, function(e)&#123; // ... &#125;, false); 1.W3C绑定的优点该方法同时支持事件处理的捕获和冒泡阶段。事件阶段取决于addEventListener最后的参数设置：false (冒泡) 或 true (捕获)。 在事件处理函数内部，this关键字引用当前元素。 事件对象总是可以通过处理函数的第一个参数(e)捕获。 可以为同一个元素绑定你所希望的多个事件，同时并不会覆盖先前绑定的事件 2.W3C绑定的缺点IE不支持，你必须使用IE的attachEvent函数替代。 IE方式123element.attachEvent(&apos;onclick&apos;, function()&#123; // ... &#125;); 1.IE方式的优点在传统绑定上，IE 是无法像 W3C 那样通过传参接受 event 对象，但如果使用了attachEvent()却可以 123box.onclick = function (evt) &#123; alert(evt); //undefined &#125; 可以为同一个元素绑定你所希望的多个事件，同时并不会覆盖先前绑定的事件。 2.IE方式的缺点IE仅支持事件捕获的冒泡阶段 事件监听函数内的this关键字指向了window对象，而不是当前元素（IE的一个巨大缺点） 事件对象仅存在与window.event参数中 事件必须以ontype的形式命名，比如，onclick而非click 仅IE可用。你必须在非IE浏览器中使用W3C的addEventListener","tags":[{"name":"javascript","slug":"javascript","permalink":"https://guoliuxu.github.io/tags/javascript/"},{"name":"冒泡","slug":"冒泡","permalink":"https://guoliuxu.github.io/tags/冒泡/"},{"name":"事件捕获","slug":"事件捕获","permalink":"https://guoliuxu.github.io/tags/事件捕获/"},{"name":"事件监听","slug":"事件监听","permalink":"https://guoliuxu.github.io/tags/事件监听/"}]},{"title":"redis的命令","date":"2017-03-23T08:41:08.000Z","path":"2017/03/23/redis的命令/","text":"Redis 命令 Redis 命令用于在 redis 服务上执行操作。 要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。 语法Redis 客户端的基本语法为：1$ redis-cli 实例以下实例讲解了如何启动 redis 客户端： 启动 redis 客户端，打开终端并输入命令 redis-cli。该命令会连接本地的 redis 服务。1234$redis-cli redis 127.0.0.1:6379&gt; redis 127.0.0.1:6379&gt; PING PONG 在以上实例中我们连接到本地的 redis 服务并执行 PING 命令，该命令用于检测 redis 服务是否启动。 在远程服务上执行命令如果需要在远程 redis 服务上执行命令，同样我们使用的也是 redis-cli 命令。 语法1$ redis-cli -h host -p port -a password 实例以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。1234567$redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;redis 127.0.0.1:6379&gt;redis 127.0.0.1:6379&gt; PINGPONG #PHP 使用 Redis ###安装开始在 PHP 中使用 Redis 前， 我们需要确保已经安装了 redis 服务及 PHP redis 驱动，且你的机器上能正常使用 PHP。 接下来让我们安装 PHP redis 驱动：下载地址为:https://github.com/nicolasff/phpredis。 PHP安装redis扩展/usr/local/php/bin/phpize #php安装后的路径./configure –with-php-config=/usr/local/php/bin/php-config make &amp;&amp; make install 修改php.ini文件1vi /usr/local/php/lib/php.ini 增加如下内容:123extension_dir = &quot;/usr/local/php/lib/php/extensions/no-debug-zts-20090626&quot;extension=redis.so 安装完成后重启php-fpm 或 apache。查看phpinfo信息，就能看到redis扩展。PHP 使用 Redis 连接到 redis 服务123456789101112&lt;?php //连接本地的 Redis 服务 $redis = new Redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); echo &quot;Connection to server sucessfully&quot;; //查看服务是否运行 echo &quot;Server is running: &quot;+ $redis-&gt;ping();?&gt;执行脚本，输出结果为： Connection to server sucessfully Server is running: PONG 123456789101112131415Redis PHP String(字符串) 实例 &lt;?php //连接本地的 Redis 服务 $redis = new Redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); echo &quot;Connection to server sucessfully&quot;; //设置 redis 字符串数据 $redis-&gt;set(&quot;tutorial-name&quot;, &quot;Redis tutorial&quot;); // 获取存储的数据并输出 echo &quot;Stored string in redis:: &quot; + jedis.get(&quot;tutorial-name&quot;); ?&gt; 执行脚本，输出结果为：Connection to server sucessfully Stored string in redis:: Redis tutorial 1234567891011121314151617181920212223Redis PHP List(列表) 实例 &lt;?php //连接本地的 Redis 服务 $redis = new Redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); echo &quot;Connection to server sucessfully&quot;; //存储数据到列表中 $redis-&gt;lpush(&quot;tutorial-list&quot;, &quot;Redis&quot;); $redis-&gt;lpush(&quot;tutorial-list&quot;, &quot;Mongodb&quot;); $redis-&gt;lpush(&quot;tutorial-list&quot;, &quot;Mysql&quot;); // 获取存储的数据并输出 $arList = $redis-&gt;lrange(&quot;tutorial-list&quot;, 0 ,5); echo &quot;Stored string in redis:: &quot; print_r($arList); ?&gt;执行脚本，输出结果为： Connection to server sucessfully Stored string in redis:: Redis Mongodb Mysql 1234567891011121314151617Redis PHP Keys 实例 &lt;?php //连接本地的 Redis 服务 $redis = new Redis(); $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); echo &quot;Connection to server sucessfully&quot;; // 获取数据并输出 $arList = $redis-&gt;keys(&quot;*&quot;); echo &quot;Stored keys in redis:: &quot; print_r($arList); ?&gt; 执行脚本，输出结果为：Connection to server sucessfully Stored string in redis:: tutorial-name tutorial-list ##Redis的数据类型12expire（为给定 key 设置生存时间）语法：expire key seconds ##String 字符串类型 一个键最多存储512M 1.SET:设置key对应值为value12语法: SET key valueSET str1 &apos;xdl&apos; 2.GET:根据KEY找到对应的值12语法: GET key注意:如果key不存在 返回nil 3.GETRANGE:返回字符串中的一部分123456语法: GETRANGE key start end GETRANGE str1 0 1GETRANGE str1 0 -1GETRANGE str1 0 -2GETRANGE str1 0 1000 4.GETSET:设置指定key的值,并返回旧值123456 语法: GETSET key value SET str2 &apos;itxdl&apos; GETSET str2 &apos;xdl&apos; 注意:当key不存在返回nil``` #### 5.MSET:一次设置多个键值对 语法:MSET key value [key value .......] MSET str4 &apos;xdl&apos; str5 &apos;itxdl&apos; str6 &apos;xdlo2o&apos; 1#### 6.SETNX:一次设置多个key-value对,只有所有的key都不存在的时候才会成功 语法: MSETNX key value [key value .....] MSETNX str10 &apos;a&apos; str11 &apos;b&apos; str12 &apos;c&apos; MSETNX str12 &apos;d&apos; str13 &apos;e&apos; 1#### 7.MGET:一次得到多个键值 语法: MGET key key MGET str4 str5 str6 1#### 8.STRLEN:获取key的字符串长度 语法: STRLEN key STRLEN str4 1#### 9.SETRANGE:相当于字符串替换 语法:SETRANGE key offset value SET str7 &apos;hello&apos; SETRANGE str7 5 &apos;xdl&apos; 注意: 如果设置key原来的字符串的长度比偏移量小,就会以零字节(\\x00)来填充 1#### 10.SETNX:只有KEY不存在的时候才能设置成功 语法: SETNX key value SETNX str7 &apos;hello&apos; 1#### 11.SETEX:设置一个KEY并且设置一个过期时间 语法: SETEX key seconds value SETEX str8 30 &apos;xdl&apos; 1#### 12.PSETEX: 以毫秒为单位设置KEY的生存周期 语法:PSEREX key milliseconds value PSETEX set9 20000 &apos;hello&apos; 1#### 13.INCR:对key中存储的数字加1 语法: INCR key SET str14 1 INCR str14 INCR str15 注意:key如果不存在,则会先初始化为0,在进行INCR操作 1#### 14.INCRBY:将key中存储的数字加上指定增量 语法: INCRBY key INCREMENT SET str16 10 INCRBY str16 5 INCRBY str16 1.5 1#### 15.INCRBYFLOAT:将key中存储的数字加上指定浮点数 语法; INCRBYFLOAT key increment SET str17 1 INCRBYFLOAT str17 1.5 1#### 16.DECR:将key中存储的数字减1 语法: DECR key SET str18 1 DECR str18 1#### 17.DECRBY:将key中存储的数值减指定值 语法: DECRBY key decrement SET str19 20 DECRBY str19 5 1#### 18.APPEND:通过APPEND将值追加到字符串末尾 语法:APPEND key value SET str20 &apos;xdl&apos; APPEND str20 &apos;o2o&apos; 12##LIST列表类型#### 1.LPUSH:向列表左端添加元素 12语法: LPUSH key value value ....LPUSH list1 a b c 2.RPUSH:向列表右端添加元素12语法: RPUSH key value ....RPUSH list1 d e 3.RANGE:获取列表片段12语法: LRANGE key start stop LRANGE list1 0 -1 4.PUSHX:向列表头部添加元素,只有key存在才添加12语法: LPUSHX key valueLPUSHX list1 a 5.PUSHX:向列表尾部添加元素,只有key存在才添加1语法: RPUSHX key value 6.LPOP:将列表头部的元素弹出12语法: LPOP key LPOP list1 7.POP:弹出列表尾部元素12语法: RPOP key RPOP list1 8.LEN:获取列表长度12语法 LLEN key LLEN list1 9.REM:删除列表中的指定值123456789语法: LREM key count valuecount &gt;0 :从列表头部开始,向尾部搜索,移除与value相等的元素,移除count个count &lt;0 :从列表的尾部开始,向头部搜索,,移除与value相等的元素,移除count个count = 0:移除列表中所有与value相等的元素LPUSH list3 a b c d a e b d c b e d LREM list3 2 aLREM list3 -2 bLREM list3 0 d 10.INDEX:获取指定索引元素上的值12语法: LIDEX key indexLINDEX list3 3 11.SET:设置指定元素的值12语法: LSET key index valueLSET list3 10 a 12.TRIM:只保留列表片段1234567语法:LTRIM key start stop LTRIM list3 0 3LPUSH list3 a b c a b c a b c LTRIM list3 0 1000 13.INSERT 向列表中插入元素123456语法: LINSERT key BEFORE|AFTER pivot valueLPUSH list4 a b c d LINSERT list4 BEFORE &apos;b&apos; &apos;x&apos;LINSERT list4 AFTER &apos;b&apos; &apos;x&apos; 14.POPLPUSH:将元素从一个列表转移到另一个列表1234语法 RPOPLPUSH source destination LPUSH list5 a b c LPUSH list6 x y z RPOPLPUSH list5 list6 ##SET集合类型:无序集合 1.SADD:向集合中添加一个元素123456``` 语法 SADD key value [,.......] SADD set1 xdl SADD set1 itxdl``` #### 2.MEMBERS:返回指定集合中的元素 语法: SMEMBERS key SMEMBERS set1 1#### 3.ISMEMBER:检查member是否是集合中的成员 语法:SISMEMBER key member SISMEMBER set1 xdl 1#### 4.REM:删除集合中一个或多个成员 语法:SREM key member [member ....] SREM set1 xdl 1#### 5.POP:删除并返回集合中的随机元素 语法: SPOP key SPOP set1 1#### 6.RANDMEMBER:随机返回集合中元素 语法: SRANDMEMBER key count 注意: count 为正数,而且小于集合中的元素,返回一个随机元素的集合数组, count 数大于集合中的个数的时候,返回整个集合 count 为负数,返回一个数组,数组中的成员可能出现重复,数组的长度是count的绝对值 SRANDMEMBER set1 -3 1#### 7.DIFF:返回集合的差集 语法: SDIFF key key .... SADD set2 a b c d SADD set3 c d e f SADD set4 a e SDIFF set3 set2 SDIFF set2 set3 set4 1#### 8.INTER:返回集合的交集 语法: SINTER key key key ... SINTER set2 set3 SADD set5 c SINTER set2 set3 set5 1#### 9.UNION:返回集合中并集 语法: SUNION key key ... SUNION set2 set3 SUNION set2 set3 set4 1#### 10.CARD:返回集合中元素个数 语法: SCARD key SCARD set2 1#### 11.DIFFSTORE:将差集的结果保存到指定的集合当中 语法: SDIFFSTORE destination key key .... SDIFFSTORE set6 set2 set3 1#### 12.INTERSTORE:将交集的结果保存到指定的集合当中 语法: SINTERSTORE destination key key .... SINTERSTORE set7 set2 set3 1#### 13.UNIONSTORE:将并集的结果保存到指定的集合当中 语法: SUNIONSTORE destination key key .... SUNIONSTORE set8 set2 set3 1#### 14.MOVE:将集合中的元素移动另一个集合中 语法 SMOVE source destination member SMOVE set3 set2 e 12##Hash类型#### 1.SET:将哈希表中的key中的field设置成指定的value 1234语法:HSET key field valueHSET h1 username &apos;zhangsan&apos;HSET h1 password &apos;123&apos;HSET h1 age &apos;18&apos; 2.GET:返回哈希表key中给的field的值123语法: HGET key fieldHGET h1 username HGET h1 age 3.SETNX:将hash表中的field设置成指定的值,只有field不存在才能成功,如果field存在,操作无效123语法 HSETNX key field valueHSETNX h1 aaa &apos;20&apos;HSETNX h1 aaa &apos;21&apos; 4.MSET:通过多个 field value设置到hash表key中12语法 HMSET key field value field value .....HMSET h2 username &apos;lisi&apos; age &apos;20&apos; password &apos;456&apos; 5.MGET:一次获得hash表key中多个field的值1234语法: HMGET key field field .....HMGET h2 username age password HMGET h2 username age password aaa 注意:如果hash表key中field不存在,返回nil 6.GETALL:返回hash表key中所有的field和value12语法 HGETALL key HGETALL h2 7.KEYS:返回hash表key中的所有的field12语法 HKEYS keyHKEYS h2 8.VALS:返回hash表key中所有的field的对应值123语法 HVALS key HVALS h2 9.EXISTS:检测hash中key的field是否存在123语法: HEXISTS key fieldHEXISTS h2 usernameHEXISTS h2 aaa 10.LEN:返回hash表key中的field的数量12语法 HLEN keyHLEN h2 11.INCRBY :给hash表key中的field做增量操作123语法 HINCRBY key field incrementHSET h3 age 20HINCRBY h3 age 5 12.INCRBYFLOAT:给hash表key中的field做增量浮点操作123语法: HINCRBYFLOAT key field incrementHSET h3 aaa &apos;12.2&apos;HINCRBYFLOAT h3 aaa 2.5 13.HDEL:删除hash中key的指定field,可删除一个或多个123语法: HDEL key field field .....HDEL h2 username HGETALL h2 ##zset(sorted set)有序集合 1.ZADD：将元素及其分数添加到集合中12345678```语法：ZADD key score member [score member]ZADD zset 100 xdl ZADD zset 98 zhangsan 98 list 80 test 78 test1 85 test2ZADD zset 60 test2 67 test3 56 test4 2.ZSCORE:获得指定元素的分数12345语法：ZSCORE key memberZSCORE zset xdlZADD zset 12.3 test5 3.ZRANGE:按照元素分数从小到大的顺序返回指定索引start到stop之间所有元素(包含两端)12345678910111213141516语法：ZRANGE key start stop [WITHSCORES]ZRANGE zset 0 -1ZRANGE zset 0 -1 WITHSCORESZRANGE zset 0 2 WITHSCORESZRANGE zset 0 2000 WITHSCORESZRANGE zset 1000 2000 WITHSCORESZADD zset 60 test6 60 test7 60 test8 60 test9注意：当两个元素的分数相同的时候，Redis在排序按照字典的顺序(0&lt;9&lt;A&lt;Z&lt;a&lt;z),如果使用的是UTF-8的编码方式的中文同样按照字典顺序排列 4.ZREVRANGE：和ZRANGE相反，按照分数从大到小的顺序123语法：ZREVRANGE key start stop [WITHSCORES]ZREVRANGE zset 0 -1 WITHSCORES 5.ZRANGEBYSCORE:获得指定分数范围内的元素，按照分数从小到大的顺序，返回的是分数在指定的min到max的元素12345678910111213141516171819语法：ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]#获得分数80~90之间的所有元素 包含80 90 ZRANGEBYSCORE zset 80 90ZADD zset 81 test9 82 test10 83 test11 84 test12 84 test13 88 test14 89 test15 90 test16ZRANGEBYSCORE zset 80 90 WITHSCORESZRANGEBYSCORE zset 80 (90 WITHSCORESZRANGEBYSCORE zset (80 (90 WITHSCORES RANGEBYSCORE zset (80 (90 WITHSCORES LIMIT 0 3注意：通过(代表不包端点 6.ZREVRANGEBYSCORE：获得指定分数范围内的元素，按照元素的分数从大到小的顺序返回min和max之间的元素123语法：ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]ZREVRANGEBYSCORE zset 90 80 WITHSCORES 7.ZINCRBY:操作某个元素的分数，返回操作之后的分数12345语法：ZINCRBY key increment memberZINCRBY zset 5 test16ZINCRBY zset -15 test16 8.ZCARD：获得集合中元素的数量123语法：ZCARD keyZCARD zset 9.ZCONUT:获得指定分数内的元素的数量1234语法：ZCOUNT key min maxZCOUNT zset 80 90COUNT zset (80 (90 10.ZREM:删除一个或者多个元素，返回删除元素的个数123语法：ZREM key member ...ZREM zset test16 11.ZREMRANGEBYRANK：按照排名范围删除元素，按照分数从小到大的顺序删除所指定的排名范围内的所有元素123456语法：ZREMRANGEBYRANK key start stopZADD testRem 1 a 2 b 3 c 4 d 5 e 6 f 7 g 8 hZREMRANGEBYRANK testRem 0 2ZRANGE testRem 0 -1 WITHSCORES 12.ZREMRANGEBYSCORE:按照分数范围删除元素123456语法：ZREMRANGEBYSCORE key min maxZADD testRem1 1 a 2 b 3 c 4 d 5 e 6 f 7 g 8 hZREMRANGEBYSCORE testRem1 3 7ZRANGE testRem1 0 -1 WITHSCORES 13.ZRANK：获得指定元素的排名，根据分数从小到大的顺序1234语法：ZRANK key memberZRANK zset xdlZRANGE zset 0 -1 WITHSCORES 14.ZREVRANK：获得指定元素的排名，根据分数从大到小的顺序1234语法：ZREVRANK key memberZREVRANK zset xdlZREVRANGE zset 0 -1 WITHSCORES 15.ZINTERSTORE：计算有序集合的交集，并将结果保存起来1234567891011121314151617语法：ZINTERSTORE destination numkeys [WEIGHTS weight weight...] [AGGREGATE SUM | MIN | MAX]ZADD zset2 1 a 2 b 3 cZADD zset3 10 a 20 b 30 cZINTERSTORE zset4 2 zset2 zset3 ZREVRANGE zset5 0 -1 WITHSCORESZINTERSTORE zset4 2 zset2 zset3 AGGREGATE SUMZINTERSTORE zset5 2 zset2 zset3 AGGREGATE MINZINTERSTORE zset6 2 zset2 zset3 AGGREGATE MAXZINTERSTORE zset7 2 zset2 zset3 WEIGHTS 2 0.2 16.ZUNIONSTORE：计算有序集合并集，将结果保存起来123456789101112131415161718语法：ZUNIONSTORE destination numkeys key key ... [WEIGHTS weight weight...] [AGGREGATE SUM | MIN | MAX]ZADD zset8 1 a 2 b 3 cZADD zset9 4 d 5 e 6 f 7 aZUNIONSTORE zset10 2 zset8 zset9ZRANGE zset10 0 -1 WITHSCORESZUNIONSTORE zset11 2 zset8 zset9 AGGREGATE SUMZRANGE zset11 0 -1 WITHSCORESZUNIONSTORE zset12 2 zset8 zset9 AGGREGATE MINZRANGE zset12 0 -1 WITHSCORESZUNIONSTORE zset13 2 zset8 zset9 AGGREGATE MAXZRANGE zset13 0 -1 WITHSCORESZUNIONSTORE zset14 2 zset8 zset9 WEIGHTS 2 2ZRANGE zset14 0 -1 WITHSCORES","tags":[{"name":"Redis","slug":"Redis","permalink":"https://guoliuxu.github.io/tags/Redis/"}]},{"title":"vagrant搭建lnmp环境","date":"2017-03-23T08:28:51.000Z","path":"2017/03/23/vagrant搭建lnmp环境/","text":"准备工作 Windows 系统或者 Mac 系统 VirtualBox 虚拟器 : https://www.virtualbox.org/ Vagrant : http://www.vagrantup.com/ box (这里的 box 指的是系统）: http://www.vagrantbox.es/ 在本地选择你要的工作目录 部署环境 1、首先，将VirtualBox 和 Vagrant 安装好！ Vagrant 是一个简单易用的部署工具，用英文说应该是 Orchestration Tool 。它能帮助开发人员迅速的构建一个开发环境，帮助测试人员构建测试环境, Vagrant 基于 Ruby 开发，使用开源 VirtualBox 作为虚拟化支持，可以轻松的跨平台部署。 通俗的来说, 就是在本地部署一个和 Linux 虚拟机上的同步文件夹, 这样所有的操作都方便了许多。 123 // 安装好后，查看下 Vagrant 版本F:\\Twitch\\test&gt;vagrant -vVagrant 1.8.6 2、进入工作文件夹 3、打开终端进入工作目录，或者你可以在当前的目录按住 shift + 鼠标右键 可快速打开当前目录的 命令窗口 1234 // 执行 vagrant box list 查看下当前 Vagrant 下部署了那些工具F:\\Twitch\\test&gt;vagrant box listubuntu16.04 (virtualbox, 0)初始安装，会告诉你什么都没有！ 4、开始添加我们准备好的 Box 镜像吧， 执行 vagrant box add 系统名字 Box镜像地址 这里因为我之前添加的是test，所以这里我另起一个工作空间 1F:\\Twitch\\laravel&gt;vagrant box add laravel /software/ubuntu16.04.box 再来查看下 我们 Vagrant 部署了那些工具吧！ 5 、添加好Box镜像后，初始化环境（Initialization environment） ，执行 vagrant init 系统名，初始化成功你的工作目录下回生成一个 Vagrantfile 的配置文件 1234567F:\\Twitch\\laravel&gt;vagrant init laravelA `Vagrantfile` has been placed in this directory. You are nowready to `vagrant up` your first virtual environment! Please readthe comments in the Vagrantfile as well as documentation on`vagrantup.com` for more information on using Vagrant.这里提示我们，将 一个 Vagrantfile 文件放入了你的工作目录，然后你可以使用 vagrant up 启动你的系统！ 6、环境配置 分配一个 IP，让本地可以访问到他，需要手动设置，默认是在 29行。 7、到这里所有的配置就完成了，执行 vagrant up 正式启航吧！启动后会在工作目录下生成一个隐藏文件夹 .vagrant 目录 分析下， 1234567891011121314151617 default: Adapter 1: nat // 网络连接模式 default: Adapter 2: hostonly // 主机==&gt; default: Forwarding ports... default: 22 (guest) =&gt; 2222 (host) (adapter 1) // 把服务器 22 端口映射到本地 2222 端口==&gt; default: Booting VM... // 启动==&gt; default: Waiting for machine to boot. This may take a few minutes... default: SSH address: 127.0.0.1:2222 // 使用127.0.0.1:2222 来连接我们的服务器 default: SSH username: vagrant // ssh 连接 用户名 default: SSH auth method: private key // 密码 default: your host and reload your VM. default: default: Guest Additions Version: 5.0.18 default: VirtualBox Version: 5.1==&gt; default: Configuring and enabling network interfaces...==&gt; default: Mounting shared folders... default: /vagrant =&gt; F:/Twitch/laravel // 服务器下的 /vagrant 目录映射我们本地的 F:/Twitch/laravel ,这两个目录是同步的,这就做到了我们在本地开发服务器上运行项目,当然这些参数都能在配置中修改 8、使用 Xshell 来连接我们的虚拟机，两种连接方式！ 使用 127.0.0.1 直接连接我们的服务器,端口 2222 ,用户名密码 vagrant ,登陆之后 你可以 sudo su 切换到 root 用户 使用 192.168.66.11 来连接服务器，端口 22 以上我们使用vagrant搭建ubuntu环境就成功了！ 最后附上vagrant一些常用的命令, 希望这能帮助你们, 别忘记点赞哟! 12345678910111213$ vagrant box add NAME URL #添加一个box$ vagrant box list #查看本地已添加的box$ vagrant box remove NAME virtualbox #删除本地已添加的box，如若是版本1.0.x，执行$ vagrant box remove NAME$ vagrant init NAME #初始化，实质应是创建Vagrantfile文件$ vagrant up #启动虚拟机$ vagrant halt #关闭虚拟机$ vagrant destroy #销毁虚拟机$ vagrant reload #重启虚拟机$ vagrant package #当前正在运行的VirtualBox虚拟环境打包成一个可重复使用的box$ vagrant ssh #进入虚拟环境打包$ vagrant package 当前要被打包的系统名 --output 打包到的地址/包名 部署LNMP 1、先更换下 apt-get 源，这里我们使用清华大学的源，权威不是！参考 12vagrant@ubuntu-xenial:/etc/apt$ sudo vim /etc/apt/sources.listvagrant@ubuntu-xenial:/etc/apt$ sudo apt-get update 2、准备工作，安装language-pack-en-bas 语言包，解决系统不同语言之间可能发生的冲突，安装之后可以减少许多因语言编码带来的问题。其中-y参数表明直接安装，无需确认。 1234567vagrant@ubuntu-xenial:~$ sudo apt-get install -y language-pack-en-base //安装成功后，运行下面这条命令，设定语言编码为 UTF-8vagrant@ubuntu-xenial:/etc/apt$ locale-gen en_US.UTF-8// 安装Git,Vimvagrant@ubuntu-xenial:~$ sudo apt-get install git vim 3、安装Nginx 123vagrant@ubuntu-xenial:~$ sudo apt-get -y install nginx vagrant@ubuntu-xenial:~$ nginx -vnginx version: nginx/1.10.0 (Ubuntu) 4、安装Mysql直接安装Mysql5.7，5.7 可以说是里程碑式的版本，提高了性能，并增加了很多新的特性。特别是新增加的json字段，用过之后你会爱上她的！！ MySQL 开发团队于 9.12 日宣布 MySQL 8.0.0 开发里程碑版本（DMR）发布！但是目前 8.0.0 还是开发版本，如果你希望体验和测试最新特性，可以从http://dev.mysql.com/downloads/mysql/ 下载各个平台的安装包。不过，MySQL 软件包是越来越大了，Linux 平台上的二进制打包后就将近有 1 GB。如果在产品环境中使用，在 8.0 没有进入稳定版本之前，请继续使用 5.7 系列，当前最新的版本是 5.7.15 GA 版本——这只有 600 M 多。 123456789101112// 1、下载.deb包到你的服务器:vagrant@ubuntu-xenial:~$ wget http://dev.mysql.com/get/mysql-apt-config_0.5.3-1_all.deb// 2、然后使用**dpkg命令添加Mysql的源：**vagrant@ubuntu-xenial:~$ sudo dpkg -i mysql-apt-config_0.5.3-1_all.deb注意: 注意在添加源的时候，会叫你选择安装 MySQL哪个应用，这里选择 Server即可，再选择 MySQL 5.7后又会回到选择应用的那个界面，此时选择Apply即可。// 3、安装vagrant@ubuntu-xenial:~$ sudo apt-get updatevagrant@ubuntu-xenial:~$ sudo apt-get install mysql-servervagrant@ubuntu-xenial:~$ mysql -Vmysql Ver 14.14 Distrib 5.7.16, for Linux (x86_64) using EditLine wrapper 5、安装PHP7.0 123456789101112131415161718192021// 1、安装php7.0vagrant@ubuntu-xenial:~$ sudo apt-get -y install php7.0vagrant@ubuntu-xenial:~$ php -vPHP 7.0.8-0ubuntu0.16.04.3 (cli) ( NTS )Copyright (c) 1997-2016 The PHP GroupZend Engine v3.0.0, Copyright (c) 1998-2016 Zend Technologies with Zend OPcache v7.0.8-0ubuntu0.16.04.3, Copyright (c) 1999-2016, by Zend Technologies// 2、安装php7.0-mysql, php7.0与mysql通信的模块，关联上vagrant@ubuntu-xenial:~$ sudo apt-get -y install php7.0-mysql// 3、安装fpm,这是Nginx用来解析php文件的：vagrant@ubuntu-xenial:~$ sudo apt-get install php7.0-fpm// 4、安装其他的必备模块vagrant@ubuntu-xenial:~$ sudo apt-get install php7.0-curlvagrant@ubuntu-xenial:~$ sudo apt-get install php7.0-xmlvagrant@ubuntu-xenial:~$ sudo apt-get install php7.0-mcryptvagrant@ubuntu-xenial:~$ sudo apt-get install php7.0-jsonvagrant@ubuntu-xenial:~$ sudo apt-get install php7.0-gdvagrant@ubuntu-xenial:~$ sudo apt-get install php7.0-mbstringvagrant@ubuntu-xenial:~$ sudo apt-get install php7.0-domvagrant@ubuntu-xenial:~$ sudo apt-get install php7.0-zip 至此与php相关的模块安装安装完成。 配置LNMP 1、配置PHP输入/fix_pathinfo搜索，将cgi.fix_pathinfo=1改为cgi.fix_pathinfo=0： 1vagrant@ubuntu-xenial:~$ sudo vim /etc/php/7.0/fpm/php.ini 2、编辑fpm配置文件： 1vagrant@ubuntu-xenial:~$ sudo vim /etc/php/7.0/fpm/pool.d/www.conf 找到listen = /run/php/php7.0-fpm.sock修改为listen = 127.0.0.1:9000。使用9000端口。12sudo service php7.0-fpm stopsudo service php7.0-fpm start 注意：如果在遇到用户权限和文件权限的问题，修改下 上图中 user 和 group ，全改为vagrant，让他对项目目录达到所有权限！ 3、配置Nginx：配置 站点 下的default文件，修改前先备份一个哦！（/etc/nginx/sites-available/） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667### You should look at the following URL&apos;s in order to grasp a solid understanding# of Nginx configuration files in order to fully unleash the power of Nginx.# http://wiki.nginx.org/Pitfalls# http://wiki.nginx.org/QuickStart# http://wiki.nginx.org/Configuration## Generally, you will want to move this file somewhere, and start with a clean# file but keep this around for reference. Or just disable in sites-enabled.## Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.### Default server configuration#server &#123; listen 80; // 监听80端口, 默认站点 #listen [::]:80 default_server; // // IPV6 开启 # SSL configuration # # listen 443 ssl default_server; # listen [::]:443 ssl default_server; # # Note: You should disable gzip for SSL traffic. # See: https://bugs.debian.org/773332 # # Read up on ssl_ciphers to ensure a secure configuration. # See: https://bugs.debian.org/765782 # # Self signed certs generated by the ssl-cert package # Don&apos;t use them in a production server! # See: https://bugs.debian.org/765782 # # Self signed certs generated by the ssl-cert package # Don&apos;t use them in a production server! # # include snippets/snakeoil.conf; root /var/www/html; // 配置网站站点目录 # Add index.php to the list if you are using PHP index index.php index.html index.htm index.nginx-debian.html; server_name localhost; // 域名 location / &#123; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. #try_files $uri $uri/ =404; //首页访问规则 // 记得修改 try_files $uri $uri/ /index.php?$query_string; &#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # // 开启这块注释，解析php文件 location ~ \\.php$ &#123; include snippets/fastcgi-php.conf; # # # With php7.0-cgi alone: // 两种方式 : 1.监听 9000 端口, 2.sock 链接, 推荐使用 1 fastcgi_pass 127.0.0.1:9000; # # With php7.0-fpm: # fastcgi_pass unix:/run/php/php7.0-fpm.sock; &#125; //注意闭合哦！ &#125; 如果是设置的 fastcgi_pass unix:/var/run/php5-fpm.sock， fpm 配置文件不需要修改, 如果是监听 9000 端口就需要修改 fpm 配置文件 vim /etc/php5/fpm/pool.d/www.conf。 123// 注释掉 sock 添加监听 9000 端口;listen = /run/php/php7.0-fpm.socklisten = 127.0.0.1:9000 fpm 配置文件修改之后, 需要重启 fpm 才能生效 service php5-fpm start, 如果想要检测 9000 端口是否开启成功运行 netstat -tln. 12vagrant@ubuntu-xenial:~$ sudo /etc/init.d/nginx restart[ ok ] Restarting nginx (via systemctl): nginx.service. 配置完后，我们来运行一个文件！ 12345vagrant@ubuntu-xenial:/var/www/html$ sudo vim phpinfo.php// 内容&lt;?phpphpinfo();?&gt; 至此，我们LNMP环境搭建完成了！","tags":[{"name":"vagrant","slug":"vagrant","permalink":"https://guoliuxu.github.io/tags/vagrant/"},{"name":"lnmp","slug":"lnmp","permalink":"https://guoliuxu.github.io/tags/lnmp/"}]},{"title":"git的一些命令","date":"2017-03-23T03:34:37.000Z","path":"2017/03/23/git的一些命令/","text":"1、直接克隆远程仓库的某个分支 git clone -b 远程分支名 远程仓库地址 本地文件夹名 如： 1git clone -b haoguozhao:shachuangbao/admin.git scb 2、普通的克隆 git clone 远程仓库地址（注意：克隆之前需要先确定远程仓库是否存在，不存在就添加一个) ##Git常用操作命令: 1. 远程仓库相关命令检出仓库：1$ git clone git://github.com/jquery/jquery.git 查看远程仓库：1$ git remote -v 添加远程仓库：1$ git remote add [name] [url] （url指的是项目的git地址，而不是gitlab服务器的域名如：[git@git.ittutorial.cn](mailto:git@git.ittutorial.cn):shachuangbao/admin.git） 删除远程仓库：1$ git remote rm [name] 修改远程仓库：1$ git remote set-url --push [name] [newUrl] 拉取远程仓库：1$ git pull [remoteName] [localBranchName] 推送远程仓库：1$ git push [remoteName] [localBranchName] 如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：12$git push origin test:master // 提交本地test分支作为远程的master分支（远程仓库名为origin）$git push origin test:test // 提交本地test分支作为远程的test分支（远程仓库名为origin） 2.分支(branch)操作相关命令 查看本地分支：1$ git branch 查看远程分支：1$ git branch -r 查看所有本地分支和远程分支：1$ git branch -a 创建本地分支：1$ git branch [name] ----注意新分支创建后不会自动切换为当前分支 切换分支：1$ git checkout [name] 创建新分支并立即切换到新分支：1$ git checkout -b [name] 删除分支：1$ git branch -d [name] ---- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项 合并分支：1$ git merge [name] ----将名称为[name]的分支与当前分支合并 创建远程分支(本地分支push到远程)：1$ git push origin [name] 删除远程分支：123$ git push origin --delete &lt;branchName&gt; 或git push origin :&lt;branchName&gt;$ git push origin test:master // 提交本地test分支作为远程的master分支$ git push origin test:test // 提交本地test分支作为远程的test分支 强推，即利用强覆盖方式用你本地的代码替代git仓库内的内容git push -f创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)123$git symbolic-ref HEAD refs/heads/[name]$rm .git/index$git clean -fdx 3.版本(tag)操作相关命令查看版本：1$ git tag 创建版本：1$ git tag [name] 删除版本：1$ git tag -d [name] 查看远程版本：1$ git tag -r 创建远程版本(本地版本push到远程)：1$ git push origin [name] 删除远程版本：1$ git push origin :refs/tags/[name]或git push origin --delete tag &lt;tagname&gt; 合并远程仓库的tag到本地：1$ git pull origin --tags 上传本地tag到远程仓库：1$ git push origin --tags 创建带注释的tag：1$ git tag -a [name] -m &apos;yourMessage&apos; 4.子模块(submodule)相关操作命令添加子模块：12$ git submodule add [url] [path] 如：$git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs 初始化子模块：12$ git submodule init ----只在首次检出仓库时运行一次就行更新子模块：$ git submodule update ----每次更新或切换分支后都需要运行一下 删除子模块：（分4步走哦）1234 1) $ git rm --cached [path] 2) 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉 3) 编辑“ .git/config”文件，将子模块的相关配置节点删除掉 4) 手动删除子模块残留的目录 5.忽略一些文件、文件夹不提交在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如123targetbin*.db ===================== Git 常用命令123456789101112131415161718192021222324252627282930313233343536373839git branch 查看本地所有分支git status 查看当前状态 git commit 提交 git branch -a 查看所有的分支git branch -r 查看本地所有分支git commit -am &quot;init&quot; 提交并且加注释 git remote add origin git@192.168.1.119:ndshowgit push origin master 将文件给推到服务器上 git remote show origin 显示远程库origin里的资源 git push origin master:developgit push origin master:hb-dev 将本地库与服务器上的库进行关联 git checkout --track origin/dev 切换到远程dev分支git branch -D master develop 删除本地库developgit checkout -b dev 建立一个新的本地分支devgit merge origin/dev 将分支dev与当前分支进行合并git checkout dev 切换到本地dev分支git remote show 查看远程库git add .git rm 文件名(包括路径) 从git中删除指定文件git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来git config --list 看所有用户git ls-files 看已经被提交的git rm [file name] 删除一个文件git commit -a 提交当前repos的所有的改变git add [file name] 添加一个文件到git indexgit commit -v 当你用－v参数的时候可以看commit的差异git commit -m &quot;This is the message describing the commit&quot; 添加commit信息git commit -a -a是代表add，把所有的change加到git index里然后再commitgit commit -a -v 一般提交命令git log 看你commit的日志git diff 查看尚未暂存的更新git rm a.a 移除文件(从暂存区和工作区中删除)git rm --cached a.a 移除文件(只从暂存区中删除)git commit -m &quot;remove&quot; 移除文件(从Git中删除)git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)git diff --cached 或 $ git diff --staged 查看尚未提交的更新git stash push 将文件给push到一个临时空间中git stash pop 将文件从临时空间pop下来git remote add origin git@github.com:username/Hello-World.gitgit push origin master 将本地项目给提交到服务器中git pull 本地与服务器端同步git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。git push origin serverfix:awesomebranchgit fetch 相当于是从远程获取最新版本到本地，不会自动mergegit commit -a -m &quot;log_message&quot; (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 git branch branch_0.1 master 从主分支master创建branch_0.1分支git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0git checkout branch_1.0/master 切换到branch_1.0/master分支","tags":[{"name":"git命令","slug":"git命令","permalink":"https://guoliuxu.github.io/tags/git命令/"}]},{"title":"负载均衡","date":"2017-03-22T12:32:11.000Z","path":"2017/03/22/负载均衡/","text":"1、搭建lnmp环境一、操作步骤1.安装Nginx12sudo apt-get install update sudo apt-get install nginx 2.测试Nginx，如果显示如下图则代表安装成功 #查看本机IP地址 12curl http://127.0.0.1 或者 curl http://本机ipcurl nginx ###3.安装MySQL1sudo apt-get install mysql-server ## 连续输入两次相同的密码 4.安装PHP1sudo apt-get install php5-fpm php5-mysql 5.配置PHP，修改php.ini文件# 备份php.ini文件1cp /etc/php5/fpm/php.ini /etc/php5/fpm/php.ini.back # 取消有安全隐患的pathinfo模式1vim /etc/php5/fpm/php.ini # 将cgi.fix_pathinfo=1 设置为 cgi.fix_pathinfo=01cgi.fix_pathinfo=0 #启动php-fpm1sudo service php5-fpm restart ###6.配置Nginx让其使用php-fpm进程 #备份/etc/nginx/sites-available/default文件1cp /etc/nginx/sites-available/default /etc/nginx/sites-available/default.back #修改defalut文件内容如下 12345678910111213141516171819202122232425262728server &#123; listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /usr/share/nginx/html; index index.php index.html index.htm; server_name server_domain_name_or_IP; location / &#123; try_files $uri $uri/ =404; &#125; error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; location ~ \\.php$ &#123; try_files $uri =404; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass unix:/var/run/php5-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 7.重启nginx服务器1sudo service nginx restart 8.在/usr/share/nginx/html/里面建立info.php写入如下内容123&lt;?php phpinfo();?&gt; 浏览器输入: http://ip/info.phpphpinfo显示 #2、nginx建立多站点 ###有两种方式 一、在default中添加server，建多少站点添加多少server在/etc/nginx/sites-available/default中： 12345678910111213141516171819202122 server&#123; listen 80;&lt;br&gt; server_name www.html1.com;&lt;br&gt; root /usr/share/nginx/html1;&lt;br&gt; index index.php index.html index.htm; location / &#123; try_files $uri $uri/ =404; &#125;&#125; server&#123; listen 80; server_name www.html1.com;&lt;br&gt; root /usr/share/nginx/html2;&lt;br&gt; index index.php index.html index.htm;&lt;br&gt; location / &#123; &lt;br&gt; try_files $uri $uri/ =404; &lt;br&gt; &#125; &lt;br&gt;&#125; 二、软链接方式；在/etc/nginx/sites-available/中复制default的文件在本目录下改文件名如：default1软链接方式如下: ln -s 到 /etc/nginx/sites-enabled/具体如下:1ln -s etc/nginx/sites-available/default1 /etc/nginx/sites-enabled/default1 最后root /usr/share/nginx/html2或root /usr/share/nginx/html1 里写文件。 3、nginx集群apache在/etc/nginx/nginx.conf中修改配置12345678910111213141516171819upstream myweb&#123;&lt;br&gt; server 192.168.20.180; server 192.168.20.101; &#125; server&#123; listen 80; server_name www.whbimuyu.com; location / &#123; index index.php index.htm; proxy_pass http://myweb; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; &#125; 4、动静分离在/etc/nginx/nginx.conf中修改配置1234567891011121314151617181920212223242526272829303132server 192.168.20.180; server 192.168.20.101; &#125; server&#123; listen 80; server_name www.whbimuyu.com; location / &#123; index index.php index.htm; proxy_pass http://myweb; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; location ~ .*\\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ &#123; root /usr/share/nginx/html; expires 3d; &#125;","tags":[{"name":"nginx","slug":"nginx","permalink":"https://guoliuxu.github.io/tags/nginx/"},{"name":"反向代理","slug":"反向代理","permalink":"https://guoliuxu.github.io/tags/反向代理/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://guoliuxu.github.io/tags/负载均衡/"}]}]